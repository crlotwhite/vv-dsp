{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 저장소 초기 설정 및 구조 생성",
        "description": "vv-dsp 프로젝트의 기본 디렉토리 구조와 빌드 시스템을 설정합니다",
        "details": "CMakeLists.txt 생성, 디렉토리 구조 생성 (core, spectral, filter, resample, envelope, window, adapters), MIT 라이선스 파일 추가, README.md 작성, .gitignore 설정, 빌드 옵션 구성 (VV_DSP_BUILD_TESTS, VV_DSP_USE_SIMD, VV_DSP_BACKEND_FFT, VV_DSP_SINGLE_FILE)",
        "testStrategy": "CMake 구성이 올바르게 빌드되고 기본 타겟이 생성되는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "CMakeLists.txt 및 빌드 시스템 설정",
            "description": "프로젝트 루트에 CMakeLists.txt를 생성하고 빌드 옵션들을 구성합니다",
            "dependencies": [],
            "details": "루트 CMakeLists.txt에서 프로젝트 이름을 vv-dsp로 설정, C99 표준 지정, 빌드 옵션들(VV_DSP_BUILD_TESTS, VV_DSP_USE_SIMD, VV_DSP_BACKEND_FFT, VV_DSP_SINGLE_FILE) 추가. CMake 최소 버전 3.15 설정, 기본 컴파일러 플래그 및 경고 옵션 구성",
            "status": "done",
            "testStrategy": "cmake -B build 명령으로 configure가 성공하고 기본 빌드 타겟이 생성되는지 확인"
          },
          {
            "id": 2,
            "title": "프로젝트 디렉토리 구조 생성",
            "description": "PRD에 명시된 모든 모듈 디렉토리와 서브디렉토리를 생성합니다",
            "dependencies": [],
            "details": "다음 디렉토리들을 생성: src/core/, src/spectral/, src/filter/, src/resample/, src/envelope/, src/window/, src/adapters/, include/vv_dsp/, tests/, examples/, docs/. 각 모듈별로 헤더 파일(.h)과 소스 파일(.c) 디렉토리 구조 준비",
            "status": "done",
            "testStrategy": "모든 필요한 디렉토리가 존재하고 적절한 권한으로 생성되었는지 확인"
          },
          {
            "id": 3,
            "title": "MIT 라이선스 및 기본 문서 작성",
            "description": "MIT 라이선스 파일과 기본 프로젝트 문서들을 생성합니다",
            "dependencies": [],
            "details": "LICENSE 파일에 표준 MIT 라이선스 텍스트 추가 (저작권자 정보 포함). README.md에 프로젝트 소개, 빌드 방법, 기본 사용법 작성. 프로젝트 목표, 기능 개요, 빌드 옵션 설명 포함",
            "status": "done",
            "testStrategy": "라이선스 파일이 유효한 MIT 형식이고 README가 마크다운으로 올바르게 렌더링되는지 확인"
          },
          {
            "id": 4,
            "title": ".gitignore 및 개발 환경 설정",
            "description": "프로젝트에 적합한 .gitignore 파일과 개발 환경 설정을 추가합니다",
            "dependencies": [],
            "details": "C/C++ 프로젝트용 .gitignore 생성 (build/, .vscode/, .vs/, *.o, *.so, *.dylib, *.dll 등). CMake 빌드 아티팩트, IDE 설정 파일, OS별 임시 파일들을 제외하도록 설정. 선택적으로 .clang-format 설정 파일 추가",
            "status": "done",
            "testStrategy": "일반적인 빌드 아티팩트들이 git status에서 무시되는지 테스트"
          },
          {
            "id": 5,
            "title": "기본 헤더 파일 및 CMake 모듈 설정 완료",
            "description": "각 모듈별 기본 헤더 파일을 생성하고 CMake 서브디렉토리를 연결합니다",
            "dependencies": [
              "1.1",
              "1.2"
            ],
            "details": "include/vv_dsp/vv_dsp.h에 메인 헤더 생성, 각 모듈별 헤더 파일들(core.h, spectral.h, filter.h, resample.h, envelope.h, window.h) 기본 구조 작성. src/ 하위 각 모듈별 CMakeLists.txt 생성하여 라이브러리 타겟 설정. 메인 CMakeLists.txt에서 add_subdirectory로 연결",
            "status": "done",
            "testStrategy": "cmake --build build 명령으로 기본 라이브러리 타겟이 성공적으로 빌드되는지 확인"
          }
        ]
      },
      {
        "id": 2,
        "title": "코어 타입 시스템 및 기본 유틸리티 구현",
        "description": "vv_dsp_real, vv_dsp_cpx, vv_dsp_status 등 핵심 데이터 타입과 기본 수학 연산을 구현합니다",
        "details": "vv_dsp_types.h에서 vv_dsp_real (float/double), vv_dsp_cpx 복소수 구조체, vv_dsp_status 상태 코드 정의. core/math.c에서 sum/mean/var, min/max, 복소수 헬퍼, 누적합, diff, clamp, denormal flush 함수 구현. C99 표준 준수, 인라인 함수 활용",
        "testStrategy": "각 수학 연산에 대한 단위 테스트 작성, NumPy 결과와 비교 검증, 경계값 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "기본 데이터 타입 및 상태 코드 정의",
            "description": "vv_dsp_types.h에서 vv_dsp_real, vv_dsp_cpx, vv_dsp_status 등 핵심 데이터 타입을 정의합니다",
            "dependencies": [],
            "details": "include/vv_dsp/vv_dsp_types.h 파일에서 vv_dsp_real을 조건부 컴파일로 float 또는 double로 정의 (VV_DSP_USE_DOUBLE 매크로 사용), vv_dsp_cpx 복소수 구조체를 real과 imag 멤버로 정의, vv_dsp_status 열거형으로 성공/실패/에러 코드 정의 (VV_DSP_OK, VV_DSP_ERROR_NULL_POINTER, VV_DSP_ERROR_INVALID_SIZE 등). C99 표준 준수, include guards와 C++ extern 지원 추가\n<info added on 2025-08-10T10:10:07.797Z>\n, vv_dsp_cpx 복소수 구조체에 관련 인라인 생성자 추가, vv_dsp_status 열거형에 VV_DSP_OK=0, VV_DSP_ERROR_OUT_OF_RANGE, VV_DSP_ERROR_INTERNAL 값 포함. 또한, 컴파일러 독립적인 static inline을 위한 VV_DSP_INLINE 매크로와 warn-unused-result를 위한 VV_DSP_NODISCARD 매크로 정의. C11 _Static_assert와 유사한 sizeof 검사 매크로를 C99 폴백과 함께 제공하며, C99 표준 준수를 유지하되 __STDC_VERSION__ >= 201112L 조건부로 _Static_assert와 같은 C11 기능 사용 허용. 마지막으로, include/vv_dsp/core.h에서 vv_dsp_types.h를 포함하도록 업데이트.\n</info added on 2025-08-10T10:10:07.797Z>",
            "status": "done",
            "testStrategy": "타입 정의가 올바르게 컴파일되고 크기가 예상값과 일치하는지 확인, C/C++ 호환성 테스트"
          },
          {
            "id": 2,
            "title": "복소수 연산 헬퍼 함수 구현",
            "description": "복소수 덧셈, 곱셈, 켤레복소수 등 기본 복소수 연산 함수들을 구현합니다",
            "dependencies": [
              "2.1"
            ],
            "details": "src/core/complex.c에서 vv_dsp_cpx_add (복소수 덧셈), vv_dsp_cpx_mul (복소수 곱셈), vv_dsp_cpx_conj (켤레복소수), vv_dsp_cpx_abs (크기), vv_dsp_cpx_phase (위상) 함수 구현. 인라인 함수 또는 매크로로 최적화 고려, NaN/Inf 처리 정책 명시. vv_dsp_cpx_from_polar (극형식 변환) 등 유틸리티 함수 포함\n<info added on 2025-08-10T10:16:58.727Z>\n실제 구현은 `src/core/core.c`에 이루어졌으며, `include/vv_dsp/core.h`에 선언되었습니다. `vv_dsp_cpx_abs`는 `hypot`을, `vv_dsp_cpx_phase`는 `atan2`를 사용하여 구현되었습니다. 안정성을 위해 `math.h`의 휴대용 함수와 `double` 중간값을 사용했습니다. NaN/Inf 처리는 현재 IEEE754 표준에 따라 전파되도록 하였으며, 이는 초기 단계에서 허용 가능한 정책입니다.\n</info added on 2025-08-10T10:16:58.727Z>",
            "status": "done",
            "testStrategy": "복소수 연산의 수학적 정확성 검증, 특별한 값(0, 무한대, NaN)에 대한 처리 테스트"
          },
          {
            "id": 3,
            "title": "기본 수학 연산 함수 구현",
            "description": "sum, mean, variance, min/max 등 기본적인 배열 연산 함수들을 구현합니다",
            "dependencies": [
              "2.1"
            ],
            "details": "src/core/math.c에서 vv_dsp_sum (배열 합계), vv_dsp_mean (평균), vv_dsp_var (분산), vv_dsp_min/vv_dsp_max (최솟값/최댓값), vv_dsp_argmin/vv_dsp_argmax (인덱스 반환) 함수 구현. 실수와 복소수 버전 모두 지원, 큰 배열에서의 수치 안정성 고려 (Kahan 합산 알고리즘 등). 입력 검증과 경계값 처리 포함\n<info added on 2025-08-10T10:17:19.997Z>\n실수 배열 버전은 `src/core/core.c`에 구현되었으며, `include/vv_dsp/core.h`에 선언됨. `sum`은 Kahan 합산, `mean`은 `sum`을 통해 계산, `var`는 Welford 알고리즘을 사용한 모집단 분산으로 구현됨. 입력 유효성 검사 시, 널 포인터 또는 크기가 0인 경우 `VV_DSP_ERROR_NULL_POINTER`를 반환하고, `var` 또는 `diff` 함수에 대해 크기가 너무 작은 경우 `VV_DSP_ERROR_INVALID_SIZE`를 반환함. 큰 배열에서의 수치 안정성을 위해 중간 계산에 `double` 타입을 사용함.\n</info added on 2025-08-10T10:17:19.997Z>",
            "status": "done",
            "testStrategy": "NumPy의 동일 함수들과 결과 비교, 큰 배열과 작은 배열에서의 정확도 검증, 수치 안정성 테스트"
          },
          {
            "id": 4,
            "title": "신호 처리 유틸리티 함수 구현",
            "description": "누적합, 차분, clamp, denormal flush 등 신호 처리에 필요한 유틸리티 함수들을 구현합니다",
            "dependencies": [
              "2.3"
            ],
            "details": "src/core/utils.c에서 vv_dsp_cumsum (누적합), vv_dsp_diff (차분), vv_dsp_clamp (값 제한), vv_dsp_flush_denormals (비정규화 수 처리) 함수 구현. 배열 기반 일괄 처리와 실시간 스트리밍을 위한 단일 값 처리 버전 모두 제공. SIMD 최적화 가능성을 고려한 메모리 정렬 처리\n<info added on 2025-08-10T10:17:50.823Z>\n이 함수들은 `include/vv_dsp/core.h`에 선언됨. `vv_dsp_flush_denormals`는 portable no-op placeholder로 구현됨. 또한, `vv_dsp_diff` 함수는 입력 크기 `n`이 2 이상이어야 하며, 그렇지 않을 경우 `VV_DSP_ERROR_INVALID_SIZE`를 반환함.\n</info added on 2025-08-10T10:17:50.823Z>",
            "status": "done",
            "testStrategy": "각 유틸리티 함수의 정확성 검증, 경계 조건과 특별한 입력값에 대한 견고성 테스트"
          },
          {
            "id": 5,
            "title": "코어 모듈 통합 및 성능 최적화",
            "description": "모든 코어 함수들을 통합하고 인라인 최적화와 SIMD 준비 작업을 완료합니다",
            "dependencies": [
              "2.2",
              "2.4"
            ],
            "details": "src/core/CMakeLists.txt에서 모든 코어 소스 파일들을 libvv_dsp_core 타겟으로 통합, include/vv_dsp/core.h에서 모든 코어 함수들의 공개 인터페이스 정의. 자주 사용되는 함수들의 인라인 최적화 적용, SIMD 준비를 위한 메모리 정렬 함수들 추가. 컴파일 시간 상수들과 매크로 정의, 전역 초기화/종료 함수 구현\n<info added on 2025-08-10T10:19:07.587Z>\n공개 인터페이스는 `include/vv_dsp/vv_dsp.h`를 통해 통합되며, `vv_dsp_types.h`가 `core.h`보다 먼저 포함됩니다. 새로운 함수들을 포함하도록 기본적인 건전성 테스트가 확장되었습니다. SIMD 준비는 향후 작업으로 남겨두며, 현재 구현은 이식성이 높고 C99를 준수합니다.\n</info added on 2025-08-10T10:19:07.587Z>",
            "status": "done",
            "testStrategy": "전체 코어 모듈의 통합 테스트, 성능 벤치마크 측정, 메모리 사용량 프로파일링, 다양한 컴파일러에서의 최적화 효과 검증"
          }
        ]
      },
      {
        "id": 3,
        "title": "윈도우 함수 생성 모듈 구현",
        "description": "boxcar, hann, hamming, blackman, nuttall 등 다양한 윈도우 함수를 구성합니다",
        "details": "window/window.h와 window/window.c에서 vv_dsp_window_boxcar, vv_dsp_window_hann, vv_dsp_window_hamming, vv_dsp_window_blackman, vv_dsp_window_blackman_harris, vv_dsp_window_nuttall 함수 구현. 각 함수는 크기와 출력 버퍼를 받아 윈도우 계수를 생성",
        "testStrategy": "scipy.signal의 윈도우 함수 결과와 비교, 대칭성 및 정규화 검증",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "윈도우 함수 헤더 파일 및 기본 구조 정의",
            "description": "window.h에서 윈도우 함수들의 함수 선언과 공통 데이터 구조를 정의합니다",
            "dependencies": [],
            "details": "src/window/window.h 파일에서 모든 윈도우 함수들(vv_dsp_window_boxcar, vv_dsp_window_hann, vv_dsp_window_hamming, vv_dsp_window_blackman, vv_dsp_window_blackman_harris, vv_dsp_window_nuttall)의 함수 시그니처를 정의합니다. 각 함수는 size_t N(윈도우 크기)과 vv_dsp_real* out(출력 버퍼)를 매개변수로 받고 vv_dsp_status를 반환합니다. 필요한 수학 상수들(M_PI 등)과 인클루드 헤더를 정의합니다.\n<info added on 2025-08-10T10:51:09.823Z>\nPublic API는 `include/vv_dsp/window.h`에 정의하며, `src/window/window.c`에서 입력 유효성 검사 및 윈도우 계수 생성을 포함한 실제 구현을 담당합니다. `vv_dsp_real` 및 `vv_dsp_status` 타입은 `vv_dsp_types.h`를 통해 제공되며, `M_PI`와 같은 수학 상수는 `<math.h>`를 포함하고 필요한 경우 폴백을 제공합니다.\n</info added on 2025-08-10T10:51:09.823Z>",
            "status": "done",
            "testStrategy": "헤더 파일이 올바르게 컴파일되고 함수 시그니처가 정확한지 확인"
          },
          {
            "id": 2,
            "title": "Boxcar 및 Hann 윈도우 함수 구현",
            "description": "가장 기본적인 boxcar 윈도우와 hann 윈도우 함수를 구현합니다",
            "dependencies": [
              "3.1"
            ],
            "details": "src/window/window.c에서 vv_dsp_window_boxcar (모든 값이 1.0인 rectangular 윈도우)와 vv_dsp_window_hann (0.5 * (1 - cos(2*π*n/(N-1))) 공식 사용) 함수를 구현합니다. 입력 검증(NULL 포인터, 크기 0 체크), 경계값 처리, 효율적인 반복문 구조를 포함합니다. C99 표준 준수와 인라인 최적화를 고려합니다.",
            "status": "done",
            "testStrategy": "scipy.signal.windows의 boxcar, hann 함수 결과와 수치적 비교, 대칭성 검증"
          },
          {
            "id": 3,
            "title": "Hamming 및 Blackman 윈도우 함수 구현",
            "description": "hamming과 blackman 윈도우 함수를 구현합니다",
            "dependencies": [
              "3.2"
            ],
            "details": "vv_dsp_window_hamming (0.54 - 0.46*cos(2*π*n/(N-1)) 공식)과 vv_dsp_window_blackman (0.42 - 0.5*cos(2*π*n/(N-1)) + 0.08*cos(4*π*n/(N-1)) 공식)을 구현합니다. 삼각함수 계산 최적화를 위해 필요시 룩업테이블이나 점진적 계산 방식을 고려합니다. 메모리 접근 패턴과 캐시 효율성을 고려한 구현을 합니다.",
            "status": "done",
            "testStrategy": "scipy.signal의 hamming, blackman 윈도우와 정확도 비교, 주파수 특성 검증"
          },
          {
            "id": 4,
            "title": "Blackman-Harris 및 Nuttall 윈도우 함수 구현",
            "description": "고급 윈도우 함수인 blackman-harris와 nuttall 윈도우를 구현합니다",
            "dependencies": [
              "3.3"
            ],
            "details": "vv_dsp_window_blackman_harris (4-term Blackman-Harris: a0=0.35875, a1=0.48829, a2=0.14128, a3=0.01168 계수 사용)와 vv_dsp_window_nuttall (Nuttall 윈도우: a0=0.3635819, a1=0.4891775, a2=0.1365995, a3=0.0106411 계수) 함수를 구현합니다. 고차 코사인 항들의 정확한 계산과 수치적 안정성을 보장합니다.",
            "status": "done",
            "testStrategy": "scipy.signal의 blackmanharris, nuttall 윈도우와 비교, 스펙트럼 누설 특성 검증"
          },
          {
            "id": 5,
            "title": "윈도우 함수 모듈 통합 및 최적화",
            "description": "모든 윈도우 함수를 통합하고 성능 최적화와 종합 테스트를 수행합니다",
            "dependencies": [
              "3.4"
            ],
            "details": "CMakeLists.txt에 window 모듈 추가, 메인 헤더(vv_dsp.h)에 window.h 인클루드, 모든 윈도우 함수의 통합 테스트 구현. SIMD 최적화 가능성 검토, 메모리 정렬 최적화, 공통 계산 부분 팩터링. 에러 핸들링 일관성 검증과 API 문서 주석 추가.\n<info added on 2025-08-10T10:54:15.162Z>\n모듈이 vv-dsp 메인 타겟에 성공적으로 연결되었고, tests/CMakeLists.txt에 새로운 윈도우 테스트가 추가됨. 기존 sanity 테스트도 윈도우 API를 사용하도록 업데이트되었으며, ctest를 통해 모든 테스트가 통과함.\n</info added on 2025-08-10T10:54:15.162Z>",
            "status": "done",
            "testStrategy": "전체 윈도우 함수 슈트의 정확도 및 성능 벤치마크, 메모리 사용량 및 캐시 효율성 측정"
          }
        ]
      },
      {
        "id": 4,
        "title": "FFT/IFFT 백엔드 시스템 및 래퍼 구현",
        "description": "선택 가능한 FFT 백엔드(KISS, FFTS, FFTW)와 통합 래퍼 인터페이스를 구현합니다",
        "details": "spectral/fft.h에서 vv_dsp_fft_plan 핸들 정의, vv_dsp_fft_make_plan, vv_dsp_fft_execute, vv_dsp_fft_destroy 함수 구현. 백엔드별 조건부 컴파일로 KISS FFT(기본), FFTS, FFTW 지원. 복소수-복소수 및 실수-복소수 변환 모두 지원",
        "testStrategy": "다양한 크기의 FFT에 대해 NumPy/SciPy FFT 결과와 비교, 역변환 정확도 검증",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "FFT API 헤더 및 기본 타입/파라미터 설계",
            "description": "vv_dsp_fft_plan 오opaque 핸들 구조체와 API 선언(생성/실행/파기)을 정의합니다",
            "dependencies": [],
            "details": "include/vv_dsp/spectral/fft.h에 vv_dsp_fft_plan(오opaque) 유형, vv_dsp_fft_dir 방향(전/역), vv_dsp_fft_type(R2C/C2R/C2C) enum 정의. vv_dsp_fft_make_plan(n, type, dir, plan**), vv_dsp_fft_execute(plan, in, out), vv_dsp_fft_destroy(plan) 선언. stride/in-place 옵션은 효율성 고려로 향후 지표 선택(기본: 연속 메모리, 아웃오브플레이스). vv_dsp_status 반환, NULL/크기 검증, C++ extern 지원",
            "status": "done",
            "testStrategy": "헤더 컴파일 및 타입/인터페이스 일관성 확인, 반환 코드 일관성 검증"
          },
          {
            "id": 2,
            "title": "백엔드 추상화 계층 및 CMake 옵션 연결",
            "description": "KISS/FFTS/FFTW 백엔드 선택 및 컴파일-시 조건부 구조를 만듭니다",
            "dependencies": [
              "4.1"
            ],
            "details": "src/spectral/fft_backend.h 내부 인터페이스(공통 함수 헤더) 정의, VV_DSP_BACKEND_FFT=KISS/FFTS/FFTW 매크로 선택. CMakeLists.txt에 백엔드 선택식 포함(기본 KISS), FFTW find_package, FFTS pkg-config 검사. VV_DSP_SINGLE_FILE 배포 방식 고려",
            "status": "done",
            "testStrategy": "CMake 구성에서 각 백엔드 선택/활성화 확인, 선택 X 시 기본 KISS 백엔드 활성화 확인"
          },
          {
            "id": 3,
            "title": "플랜 생성/파기 및 파라미터 검증 구현",
            "description": "크기/방향/유형에 따른 plan 생성, 메모리 할당, 값 검증 및 파기를 구현합니다",
            "dependencies": [
              "4.2"
            ],
            "details": "src/spectral/fft.c에 vv_dsp_fft_make_plan/vv_dsp_fft_destroy 구현: n>0, 자연수 체크, type(dir) 유효성 검증, 필요 메모리 할당(입/출력 버퍼, scratch). 크기 변경과 다유 백엔드 가능성 점검, 에러 코드 반환",
            "status": "done",
            "testStrategy": "다양한 n(2^k, 속수, 소수)에서 plan 생성/파기 테스트, 메모리 누수 검사"
          },
          {
            "id": 4,
            "title": "KISS 백엔드 C2C 실행 기반 구현",
            "description": "기본 백엔드(KISS)로 복소수-복소수 전/역 FFT 실행을 구현합니다",
            "dependencies": [
              "4.3"
            ],
            "details": "src/spectral/fft_kiss.c 또는 동향 파일에 KISS FFT 엔진 래퍼 구현(별도 포함 또는 submodule). vv_dsp_fft_execute 구현: C2C forward/backward, 연속 버퍼 입/출력(아웃에 대한 in-place 선택 가능). NaN/Inf 에러 판별",
            "status": "done",
            "testStrategy": "알려진 단발 주파수 신호에 대한 C2C FFT/IFFT 역변환 정확도 검증(원본 복원), NumPy numpy.fft.fft 비교"
          },
          {
            "id": 5,
            "title": "KISS 백엔드 R2C/C2R 변환 호출 구현",
            "description": "실수-복소수 및 복소수-실수 변환을 지원하는 API 를 구현합니다",
            "dependencies": [
              "4.4"
            ],
            "details": "vv_dsp_fft_type=R2C/C2R 포함 plan 지원 및 vv_dsp_fft_execute 내부 변환 로직. 반환 포맷과 출력 크기(훅킹) 명시, Nyquist 항 처리, 내부 재정규화(의미론 대체 안함). 다무한 n 지원",
            "status": "done",
            "testStrategy": "numpy.fft.rfft/irfft 결과와 비교(표준화 처리 포함), 역변환 통해 L2 오차 측정"
          },
          {
            "id": 6,
            "title": "FFTS 백엔드 연결(선택) 및 적용 인터페이스",
            "description": "FFTS 백엔드 선택 시 적용되도록 adapter 를 구현합니다",
            "dependencies": [
              "4.3"
            ],
            "details": "src/spectral/fft_ffs.c(또는 .c)에 FFTS API 래퍼. CMake 선택 시에만 컴파일, 미 설치 시 폴백 또는 기본 KISS 환경 바로 회귀. C2C/R2C/C2R 기본 지원",
            "status": "deferred",
            "testStrategy": "FFTS 설치 환경에서 동일 테스트 지향, 기본 KISS 결과와 수치 일관성 확인"
          },
          {
            "id": 7,
            "title": "FFTW 백엔드 연결(선택) 및 plan 플래그 지원",
            "description": "FFTW3 연결 및 wisdom/threads(선택) 지원 adapter 구현",
            "dependencies": [
              "4.3"
            ],
            "details": "src/spectral/fft_fftw.c에 FFTW planner 래퍼. find_package(FFTW3) 성공 시에만 컴파일, plan 생성 파라미터(시간 vs. 가능함) 바로 고려. optional: wisdom load/save, threads 지원(FFTW 키포드)",
            "status": "deferred",
            "testStrategy": "FFTW 환경에서 NumPy/SciPy 결과와 비교, plan 선택 옵션 변환 시 성능 변화 확인"
          },
          {
            "id": 8,
            "title": "스펙트럼 유틸(fftshift/ifftshift) 및 모듈 통합/테스트",
            "description": "fftshift/ifftshift 유틸리티를 구현하고 spectral 모듈 통합 및 종합 테스트를 수행합니다",
            "dependencies": [
              "4.5"
            ],
            "details": "src/spectral/utils.c에 vv_dsp_fftshift/vv_dsp_ifftshift 구현(연속 버퍼, in-place 또는 out-of-place 버전). CMake에 spectral 모듈 강화, include/vv_dsp/vv_dsp.h에 fft.h 포함. 통합 테스트: C2C/R2C/C2R 반환 정확도, 사용성/성능 벤치마크",
            "status": "done",
            "testStrategy": "NumPy numpy.fft.fftshift/ifftshift 비교, STFT 요소런 조합에서 위상 검증, 전체 FFT 통합 테스트"
          }
        ]
      },
      {
        "id": 5,
        "title": "STFT/ISTFT 스펙트로그램 분석 모듈 구현",
        "description": "Short-Time Fourier Transform과 역변환을 위한 프레이밍 및 overlap-add 처리를 구현합니다",
        "details": "spectral/stft.h와 stft.c에서 vv_dsp_stft 핸들 생성, 프레임 단위 STFT 처리, overlap-add를 통한 ISTFT 재구성. 윈도우 적용, 홉 크기 설정, 프레임 버퍼 관리 포함. fetch_frame과 overlap-add 헬퍼 함수 구현",
        "testStrategy": "완전 재구성 테스트 (STFT->ISTFT 후 원본 신호 복원), 위상 일관성 검증",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "STFT 핸들 구조체 정의 및 기본 인터페이스 구현",
            "description": "vv_dsp_stft 핸들 구조체와 생성/소멸 함수를 정의합니다",
            "dependencies": [],
            "details": "src/spectral/stft.h에서 vv_dsp_stft 구조체 정의 (FFT 플랜, 윈도우 버퍼, 홉 크기, 프레임 크기, 오버랩 버퍼 포함), vv_dsp_stft_create, vv_dsp_stft_destroy 함수 선언. src/spectral/stft.c에서 메모리 할당/해제, FFT 플랜 초기화, 파라미터 검증 구현. 윈도우 크기, 홉 크기, FFT 크기 설정 가능하도록 구성",
            "status": "done",
            "testStrategy": "핸들 생성/소멸의 메모리 누수 검사, 다양한 파라미터 조합에서 초기화 성공 확인"
          },
          {
            "id": 2,
            "title": "프레임 버퍼 관리 및 윈도우 적용 시스템 구현",
            "description": "입력 신호로부터 프레임을 추출하고 윈도우 함수를 적용하는 기능을 구현합니다",
            "dependencies": [
              "5.1"
            ],
            "details": "vv_dsp_stft_fetch_frame 헬퍼 함수로 입력 버퍼에서 현재 프레임 추출, 제로 패딩 처리. 윈도우 함수 적용을 위한 임시 버퍼 관리, 선택된 윈도우 타입(hann, hamming 등)에 따른 윈도우 계수 적용. 프레임 경계 처리 및 부족한 샘플에 대한 제로 패딩 로직 구현",
            "status": "done",
            "testStrategy": "다양한 프레임 크기와 윈도우 타입으로 프레임 추출 정확도 확인, 경계 조건 테스트"
          },
          {
            "id": 3,
            "title": "STFT 분석 처리 함수 구현",
            "description": "프레임 단위로 STFT를 수행하는 핵심 분석 함수를 구현합니다",
            "dependencies": [
              "5.2"
            ],
            "details": "vv_dsp_stft_process 함수로 입력 프레임에 윈도우 적용 후 FFT 실행, 복소수 스펙트럼 출력. 실시간 처리를 위한 스트리밍 인터페이스 구현, 내부 상태 관리 (이전 프레임 오버랩 부분). 홉 크기에 따른 프레임 진행 관리, 출력 스펙트럼 포맷 (크기/위상 또는 실수/허수) 선택 가능",
            "status": "done",
            "testStrategy": "알려진 주파수 신호의 STFT 결과와 NumPy/SciPy 비교, 다양한 홉 크기에서 정확도 검증"
          },
          {
            "id": 4,
            "title": "ISTFT overlap-add 재구성 시스템 구현",
            "description": "STFT 결과로부터 시간 영역 신호를 재구성하는 ISTFT 기능을 구현합니다",
            "dependencies": [
              "5.3"
            ],
            "details": "vv_dsp_stft_reconstruct 함수로 복소수 스펙트럼에 IFFT 적용, overlap-add 방식으로 출력 신호 재구성. 오버랩 버퍼 관리 (이전 프레임과의 중첩 부분 누적), 윈도우 정규화 처리 (COLA 조건 보장). 프레임 간 연속성 유지를 위한 상태 관리, 지연 보상 옵션 제공",
            "status": "done",
            "testStrategy": "STFT->ISTFT 완전 재구성 테스트 (원본 신호와 비교), 다양한 윈도우와 홉 크기 조합에서 재구성 품질 측정"
          },
          {
            "id": 5,
            "title": "STFT 모듈 통합 및 고급 기능 구현",
            "description": "STFT 모듈을 완성하고 스펙트로그램 생성, 위상 처리 등 고급 기능을 추가합니다",
            "dependencies": [
              "5.4"
            ],
            "details": "vv_dsp_stft_spectrogram 함수로 전체 신호의 스펙트로그램 행렬 생성, 시간-주파수 표현 출력. 위상 일관성 유지를 위한 위상 vocoder 기반 처리 옵션, 스펙트럼 크기/위상 분리 추출 기능. CMakeLists.txt에 spectral 모듈 통합, 메인 헤더에 STFT 인터페이스 포함, 종합 테스트와 성능 최적화 적용",
            "status": "done",
            "testStrategy": "전체 신호 스펙트로그램 생성 정확도 검증, 실시간 처리 성능 벤치마크, 위상 일관성 측정"
          }
        ]
      },
      {
        "id": 6,
        "title": "보간 및 리샘플링 모듈 구현",
        "description": "선형/구간 보간과 polyphase 리샘플러를 구현하여 샘플레이트 변환을 지원합니다",
        "details": "resample/interpolate.c에서 선형 및 구간 보간 함수, resample/resampler.c에서 vv_dsp_resampler 핸들과 polyphase 필터 기반 리샘플러 구현. 정수/분수 비율 리샘플링 지원, 선택적 sinc 업샘플러 추가. 안티앨리어싱 필터 자동 적용",
        "testStrategy": "알려진 주파수 신호의 리샘플링 정확도 검증, 앨리어싱 방지 효과 측정",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "resample/interpolate 모듈 초기 설정 및 선형 보간 구현",
            "description": "`resample/interpolate.h` 및 `resample/interpolate.c` 파일을 생성하고, `vv_dsp_real` 타입에 대한 선형 보간 함수 `vv_dsp_interpolate_linear_real`을 구현합니다.",
            "dependencies": [],
            "details": "1. `resample/interpolate.h` 파일을 생성하고 `vv_dsp_interpolate_linear_real` 함수의 시그니처를 선언합니다.\n2. `resample/interpolate.c` 파일을 생성하고 `vv_dsp_interpolate_linear_real` 함수를 구현합니다. 이 함수는 입력 배열, 출력 배열, 보간할 위치(0.0-1.0 사이의 비율)를 인자로 받아야 합니다.\n3. Task 2에서 정의될 `vv_dsp_real` 타입을 사용합니다.\n<info added on 2025-08-10T11:31:30.594Z>\n[\n  0\n]\n</info added on 2025-08-10T11:31:30.594Z>",
            "status": "done",
            "testStrategy": "알려진 입력 값과 보간 위치에 대해 수동으로 계산한 결과와 비교하여 `vv_dsp_interpolate_linear_real`의 정확성을 검증합니다."
          },
          {
            "id": 2,
            "title": "resample/interpolate 모듈에 구간 보간 함수 추가",
            "description": "`resample/interpolate.c`에 `vv_dsp_real` 타입에 대한 구간 보간 (예: 큐빅 또는 라그랑주) 함수 `vv_dsp_interpolate_cubic_real`을 구현합니다.",
            "dependencies": [
              "6.1"
            ],
            "details": "1. `resample/interpolate.h`에 `vv_dsp_interpolate_cubic_real` 함수의 시그니처를 선언합니다.\n2. `resample/interpolate.c`에 `vv_dsp_interpolate_cubic_real` 함수를 구현합니다. 이 함수는 선형 보간과 유사한 인터페이스를 가지되, 주변 샘플을 활용하여 더 부드러운 보간을 수행해야 합니다.\n3. `vv_dsp_real` 타입을 사용합니다.\n<info added on 2025-08-10T11:32:33.504Z>\nCatmull-Rom 스타일의 큐빅 보간 함수 `vv_dsp_interpolate_cubic_real`이 `resample/interpolate.h`에 선언되고 `resample/interpolate.c`에 경계 클램핑 방식으로 구현되었습니다. 빌드 및 기존 테스트가 성공적으로 완료되었습니다.\n</info added on 2025-08-10T11:32:33.504Z>",
            "status": "done",
            "testStrategy": "단순한 곡선 데이터에 대해 보간 결과를 시각화하고, 알려진 수학 함수에 대한 보간 결과와 비교하여 `vv_dsp_interpolate_cubic_real`의 정확성과 부드러움을 검증합니다."
          },
          {
            "id": 3,
            "title": "vv_dsp_resampler 핸들 및 기본 구조 정의",
            "description": "`resample/resampler.h` 및 `resample/resampler.c` 파일을 생성하고, `vv_dsp_resampler` 핸들(불투명 포인터)과 생성/소멸 함수 `vv_dsp_resampler_create`, `vv_dsp_resampler_destroy`를 구현합니다.",
            "dependencies": [],
            "details": "1. `resample/resampler.h` 파일을 생성하고 `typedef struct vv_dsp_resampler vv_dsp_resampler;` 선언 및 `vv_dsp_resampler_create`, `vv_dsp_resampler_destroy` 함수 시그니처를 선언합니다.\n2. `resample/resampler.c` 파일을 생성하고 `struct vv_dsp_resampler`의 실제 정의(내부 상태, 필터 계수 등을 포함할 구조) 및 `vv_dsp_resampler_create`, `vv_dsp_resampler_destroy` 함수를 구현합니다.\n3. `create` 함수는 샘플레이트 비율, 필터 타입 등 초기 파라미터를 받을 수 있도록 설계하고, 메모리 할당 및 해제 로직을 포함합니다.\n<info added on 2025-08-10T11:33:44.480Z>\n`include/vv_dsp/resample.h` 파일을 생성하여 리샘플러 API를 내보내고, `src/resample/CMakeLists.txt`에 `resampler.c`를 추가했습니다. 빌드 및 기존 테스트가 모두 성공적으로 통과했습니다.\n</info added on 2025-08-10T11:33:44.480Z>",
            "status": "done",
            "testStrategy": "`vv_dsp_resampler_create` 및 `vv_dsp_resampler_destroy` 함수 호출 시 메모리 누수가 없는지, 유효하지 않은 파라미터에 대해 적절한 `vv_dsp_status`를 반환하는지 확인합니다."
          },
          {
            "id": 4,
            "title": "Polyphase 리샘플러 핵심 처리 로직 구현 (고정 비율)",
            "description": "`resample/resampler.c`에 `vv_dsp_resampler_process_real` 함수를 구현하여 `vv_dsp_real` 데이터에 대한 polyphase 필터 기반 리샘플링을 수행합니다. 초기에는 고정된 정수 또는 간단한 분수 비율 리샘플링을 지원합니다.",
            "dependencies": [
              "6.3"
            ],
            "details": "1. `resample/resampler.h`에 `vv_dsp_resampler_process_real` 함수의 시그니처를 선언합니다.\n2. `resample/resampler.c`에 `vv_dsp_resampler_process_real` 함수를 구현합니다. 이 함수는 입력 버퍼, 출력 버퍼, 처리할 샘플 수를 인자로 받습니다.\n3. 내부적으로 polyphase 필터 뱅크를 사용하여 리샘플링을 수행하며, 간단한 안티앨리어싱 필터 로직을 포함합니다 (예: 고정된 저역 통과 필터).\n<info added on 2025-08-10T11:35:26.826Z>\n현재 구현은 초기 단계로, polyphase 필터 대신 선형 보간을 사용하여 고정 비율 리샘플링을 처리합니다. 향후 polyphase/sinc 구현을 위해 품질 및 비율 설정 함수가 플레이스홀더로 추가되었습니다. 빌드 및 기존 ctest 검증이 완료되었습니다.\n</info added on 2025-08-10T11:35:26.826Z>",
            "status": "done",
            "testStrategy": "단일 주파수 사인파를 입력하여 리샘플링 후 주파수 스펙트럼을 분석하여 올바른 샘플레이트 변환이 이루어졌는지, 앨리어싱이 억제되는지 확인합니다."
          },
          {
            "id": 5,
            "title": "가변 비율 리샘플링, Sinc 업샘플러 및 자동 안티앨리어싱 필터 구현",
            "description": "`vv_dsp_resampler`에 가변 비율 리샘플링 기능을 추가하고, 선택적 Sinc 업샘플러를 구현하며, 리샘플링 비율에 따른 안티앨리어싱 필터를 자동으로 적용하는 로직을 완성합니다.",
            "dependencies": [
              "6.4"
            ],
            "details": "1. `vv_dsp_resampler_create` 또는 별도의 설정 함수를 통해 가변 비율 리샘플링을 지원하도록 `vv_dsp_resampler` 구조를 확장합니다.\n2. Sinc 함수 기반의 고품질 업샘플링 필터를 구현하고, 필요에 따라 이를 선택적으로 사용할 수 있도록 합니다.\n3. 리샘플링 비율(업샘플링/다운샘플링)에 따라 적절한 차단 주파수를 가진 안티앨리어싱/안티이미징 필터를 동적으로 설계하거나 선택하여 적용하는 로직을 구현합니다.\n<info added on 2025-08-10T11:38:36.108Z>\nHann 윈도우를 적용한 윈도우드 Sinc 필터 기반의 리샘플링 경로가 구현되었으며, 리샘플링 비율에 따른 자동 차단 주파수 조정 로직이 적용되었습니다. 선형 보간 폴백 옵션이 추가되었고, 설정을 위한 세터 함수들이 `resampler.h`에 노출되었습니다. 가변 비율 API 구현은 현재 필요 시로 연기되었습니다.\n</info added on 2025-08-10T11:38:36.108Z>",
            "status": "done",
            "testStrategy": "다양한 정수/분수 비율로 리샘플링을 수행하여 출력 신호의 정확도와 앨리어싱/이미징 억제 효과를 검증합니다. 특히 Sinc 업샘플러의 품질을 기존 방식과 비교합니다."
          }
        ]
      },
      {
        "id": 7,
        "title": "필터 설계 및 처리 모듈 구현",
        "description": "FIR 및 IIR(biquad) 필터 설계와 적용 함수를 구현합니다",
        "details": "filter/fir.h와 fir.c에서 vv_dsp_fir_design_lowpass, 컨볼루션 기반 FIR 필터 적용. filter/iir.c에서 vv_dsp_biquad 구조체와 2차 IIR 필터 처리. 선택적으로 filtfilt (영위상 필터링) 구현. FFT 기반 긴 컨볼루션 지원",
        "testStrategy": "주파수 응답 검증, 필터 안정성 테스트, 임펄스/스텝 응답 확인",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "API/File Scaffolding for Filter Module",
            "description": "Create the necessary header and source files for the filter module: `filter/fir.h`, `filter/fir.c`, `filter/iir.h`, `filter/iir.c`, and `filter/common.h`/`filter/common.c` for shared utilities. Establish basic file structure, include guards, and `extern \"C\"` blocks. Define common enums like `vv_dsp_window_type`.",
            "dependencies": [],
            "details": "Files to create: `filter/fir.h`, `filter/fir.c`, `filter/iir.h`, `filter/iir.c`, `filter/common.h`, `filter/common.c`. Each `.h` file must have standard header guards and `extern \"C\"` blocks. Include `core/vv_dsp_types.h` in all `.c` files and relevant `.h` files. Define `typedef enum { VV_DSP_WINDOW_RECTANGULAR, VV_DSP_WINDOW_HAMMING, VV_DSP_WINDOW_HANNING, VV_DSP_WINDOW_BLACKMAN } vv_dsp_window_type;` in `filter/common.h`.",
            "status": "done",
            "testStrategy": "Verify file existence and correct header guard/C linkage. Ensure compilation without errors for empty files."
          },
          {
            "id": 2,
            "title": "FIR Low-pass Filter Design Implementation",
            "description": "Implement the `vv_dsp_fir_design_lowpass` function to calculate FIR filter coefficients using a windowing method. Support configurable window types (e.g., Rectangular, Hamming, Hanning, Blackman) as defined in `vv_dsp_window_type`.",
            "dependencies": [
              "7.1"
            ],
            "details": "File: `filter/fir.h`, `filter/fir.c`. Public API: `vv_dsp_status vv_dsp_fir_design_lowpass(vv_dsp_real* coeffs, size_t num_taps, vv_dsp_real cutoff_norm, vv_dsp_window_type window_type);`. Input: `coeffs` (output buffer for coefficients), `num_taps` (filter order + 1), `cutoff_norm` (normalized cutoff frequency 0-1, 1 = Nyquist), `window_type`. Output: `coeffs` array populated, `vv_dsp_status` (e.g., `VV_DSP_SUCCESS`, `VV_DSP_ERROR_INVALID_ARGUMENT` for `cutoff_norm` out of range). Completion: Coefficients are correctly calculated for various window types and cutoff frequencies.",
            "status": "done",
            "testStrategy": "Unit tests comparing generated coefficients against known values (e.g., SciPy/MATLAB) for various `num_taps`, `cutoff_norm`, and `window_type`. Check edge cases like `cutoff_norm` near 0 or 1."
          },
          {
            "id": 3,
            "title": "FIR Time-Domain Convolution Application",
            "description": "Implement a function to apply an FIR filter to a block of input samples using direct time-domain convolution. This function should manage internal state for streaming processing.",
            "dependencies": [
              "7.1"
            ],
            "details": "File: `filter/fir.h`, `filter/fir.c`. Public API: `typedef struct { vv_dsp_real* history; size_t history_size; size_t history_idx; size_t num_taps; } vv_dsp_fir_state;`. Functions: `vv_dsp_status vv_dsp_fir_state_init(vv_dsp_fir_state* state, size_t num_taps);`, `void vv_dsp_fir_state_free(vv_dsp_fir_state* state);`, `vv_dsp_status vv_dsp_fir_apply(vv_dsp_fir_state* state, const vv_dsp_real* coeffs, const vv_dsp_real* input, vv_dsp_real* output, size_t num_samples);`. Input: `state` (filter state), `coeffs` (filter coefficients), `input` (input samples), `num_samples`. Output: `output` (processed samples), `vv_dsp_status`. Completion: Filter correctly applies convolution, handles history for block processing.",
            "status": "done",
            "testStrategy": "Unit tests with known impulse responses and step responses. Verify output matches expected values for various input block sizes, including streaming (multiple calls). Check for correct state management and memory handling."
          },
          {
            "id": 4,
            "title": "IIR Biquad Structure and Initialization",
            "description": "Define the `vv_dsp_biquad` structure to hold IIR filter coefficients and state variables. Implement an initialization function to set up a biquad filter instance and a reset function.",
            "dependencies": [
              "7.1"
            ],
            "details": "File: `filter/iir.h`, `filter/iir.c`. Public API: `typedef struct { vv_dsp_real a1, a2, b0, b1, b2; vv_dsp_real z1, z2; } vv_dsp_biquad;` (Direct Form II Transposed is recommended). Functions: `vv_dsp_status vv_dsp_biquad_init(vv_dsp_biquad* biquad, vv_dsp_real b0, vv_dsp_real b1, vv_dsp_real b2, vv_dsp_real a1, vv_dsp_real a2);`, `void vv_dsp_biquad_reset(vv_dsp_biquad* biquad);`. Input: `biquad` (pointer to structure), `b0, b1, b2, a1, a2` (filter coefficients). Output: `biquad` initialized, `vv_dsp_status`. Completion: Structure defined, initialization function correctly sets coefficients and resets state variables (`z1, z2` to 0).",
            "status": "done",
            "testStrategy": "Unit tests to verify `vv_dsp_biquad_init` correctly assigns coefficients and zeroes out state. Test `vv_dsp_biquad_reset` functionality."
          },
          {
            "id": 5,
            "title": "IIR Biquad Sample Processing",
            "description": "Implement the core processing function for a single biquad filter stage. This function will take an input sample and return an output sample, updating the internal state.",
            "dependencies": [
              "7.4"
            ],
            "details": "File: `filter/iir.h`, `filter/iir.c`. Public API: `vv_dsp_real vv_dsp_biquad_process(vv_dsp_biquad* biquad, vv_dsp_real input_sample);`. Input: `biquad` (pointer to structure), `input_sample` (single sample). Output: Processed `vv_dsp_real` sample. Completion: Single sample processing correctly implements Direct Form II Transposed biquad equations.",
            "status": "done",
            "testStrategy": "Unit tests with simple coefficients (e.g., pass-through, delay). Test impulse and step responses for known biquad coefficients. Verify state updates correctly after each sample."
          },
          {
            "id": 6,
            "title": "IIR Biquad Block Processing",
            "description": "Implement a function to apply a series of biquad filter stages to a block of input samples. This will typically involve chaining multiple `vv_dsp_biquad` instances.",
            "dependencies": [
              "7.5"
            ],
            "details": "File: `filter/iir.h`, `filter/iir.c`. Public API: `vv_dsp_status vv_dsp_iir_apply(vv_dsp_biquad* biquads, size_t num_stages, const vv_dsp_real* input, vv_dsp_real* output, size_t num_samples);`. Input: `biquads` (array of biquad structures), `num_stages` (number of biquad stages), `input` (input samples), `num_samples`. Output: `output` (processed samples), `vv_dsp_status`. Completion: Block processing correctly applies multiple biquad stages in series.",
            "status": "done",
            "testStrategy": "Unit tests with multi-stage IIR filters. Compare output against SciPy `lfilter` for known coefficients. Test various block sizes and ensure correct state propagation between stages."
          },
          {
            "id": 7,
            "title": "Zero-Phase Filtering (filtfilt) Implementation",
            "description": "Implement a zero-phase filtering function (`filtfilt`) that applies a filter forward and backward to eliminate phase distortion. Start with FIR filter support.",
            "dependencies": [
              "7.3"
            ],
            "details": "File: `filter/common.h`, `filter/common.c`. Public API: `vv_dsp_status vv_dsp_filtfilt_fir(const vv_dsp_real* coeffs, size_t num_taps, const vv_dsp_real* input, vv_dsp_real* output, size_t num_samples);`. Input: `coeffs`, `num_taps`, `input`, `num_samples`. Output: `output` (zero-phase filtered samples), `vv_dsp_status`. Completion: `filtfilt` correctly processes data, handles padding/reflection at boundaries to minimize transients. Consider using `vv_dsp_fir_apply` internally.",
            "status": "done",
            "testStrategy": "Unit tests comparing `filtfilt` output against SciPy `filtfilt` for various FIR filters. Verify phase response is flat. Test boundary conditions and padding strategies."
          },
          {
            "id": 8,
            "title": "FFT-based Long FIR Convolution (Conditional)",
            "description": "Implement FFT-based convolution for long FIR filters using Overlap-Save or Overlap-Add method. This subtask is conditional on Task 4 (FFT module) being available and functional.",
            "dependencies": [
              "7.3"
            ],
            "details": "File: `filter/fir.h`, `filter/fir.c`. Public API: `vv_dsp_status vv_dsp_fir_apply_fft(vv_dsp_fir_state* state, const vv_dsp_real* coeffs, const vv_dsp_real* input, vv_dsp_real* output, size_t num_samples);`. This function will depend on the `fft` module (Task 4). Implement either Overlap-Save or Overlap-Add. Completion: FFT-based convolution produces results identical to time-domain convolution for long filters, with potential performance benefits.",
            "status": "done",
            "testStrategy": "Compare output against `vv_dsp_fir_apply` for various filter lengths and input sizes. Benchmark performance against time-domain convolution for long filters. This subtask should only be attempted if Task 4 is complete."
          },
          {
            "id": 9,
            "title": "Filter Module Unit Tests and Basic Benchmarking",
            "description": "Create comprehensive unit tests for FIR and IIR filter functions, covering frequency response, impulse/step response, stability, and boundary conditions. Implement basic performance benchmarks for key processing functions.",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4",
              "7.5",
              "7.6",
              "7.7",
              "7.8"
            ],
            "details": "File: `tests/filter_test.c` (new file). Test Cases: FIR low-pass design and application (frequency, impulse, step response). IIR biquad processing (impulse, step response, stability for high-Q). `filtfilt` correctness. Boundary conditions (e.g., `num_taps=1`, `cutoff_norm=0/1`). Benchmarking: Simple time measurements for `vv_dsp_fir_apply`, `vv_dsp_iir_apply`, and `vv_dsp_fir_apply_fft` (if implemented) with different block sizes and filter orders. Completion: All core filter functions are thoroughly tested for correctness and basic performance.",
            "status": "done",
            "testStrategy": "Use helper functions to generate frequency/impulse/step responses. Compare against known DSP library outputs (e.g., SciPy). Ensure tests cover edge cases and error conditions."
          },
          {
            "id": 10,
            "title": "Documentation and Example Usage",
            "description": "Add Doxygen-style comments to all public API functions in `filter/fir.h`, `filter/iir.h`, and `filter/common.h`. Create a simple example demonstrating FIR and IIR filter usage.",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4",
              "7.5",
              "7.6",
              "7.7",
              "7.8"
            ],
            "details": "File: Update `filter/*.h` files with Doxygen comments. Create `examples/filter_example.c`. Documentation: Function descriptions, parameter explanations, return values, error conditions, usage notes. Example: A simple C program demonstrating how to design an FIR filter, initialize an IIR biquad, and apply them to a synthetic signal (e.g., sine wave, impulse).",
            "status": "done",
            "testStrategy": "Verify documentation format and completeness. Compile and run the example to ensure it works as expected and demonstrates correct usage of the filter module APIs."
          }
        ]
      },
      {
        "id": 8,
        "title": "켑스트럼 및 최소위상 변환 모듈 구현",
        "description": "실켄셰번스 켑스트럼과 최소위상 변환을 구현하여 위상 처리를 지원합니다",
        "details": "envelope/cepstrum.c에서 vv_dsp_rceps (실켄셰번스 켑스트럼), vv_dsp_irceps (역변환) 구현. envelope/minphase.c에서 vv_dsp_minphase를 통한 최소위상 변환. 로그 스펙트럼 계산과 위상 언랩/랩 유틸리티 포함",
        "testStrategy": "알려진 신호의 켑스트럼 계산 정확도 검증, 최소위상 변환 후 크기 스펙트럼 보존 확인",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "실켄셰번스 켑스트럼 헤더 파일 정의",
            "description": "envelope/cepstrum.h 파일을 생성하고 실켄셰번스 켑스트럼 관련 함수들의 선언을 정의합니다",
            "dependencies": [],
            "details": "envelope/cepstrum.h에서 vv_dsp_rceps (실켄셰번스 켑스트럼 변환), vv_dsp_irceps (역변환) 함수 선언. 복소수 배열과 실수 켑스트럼 배열을 다루는 인터페이스 정의. vv_dsp_real, vv_dsp_cpx, vv_dsp_status 타입 사용. 함수 매개변수로 입력 신호, 출력 버퍼, 신호 길이 등을 포함",
            "status": "done",
            "testStrategy": "헤더 파일이 올바르게 컴파일되고 타입 정의가 일관성 있게 작성되었는지 확인"
          },
          {
            "id": 2,
            "title": "실켄셰번스 켑스트럼 변환 구현",
            "description": "envelope/cepstrum.c에서 실켄셰번스 켑스트럼 변환 알고리즘을 구현합니다",
            "dependencies": [
              "8.1"
            ],
            "details": "vv_dsp_rceps 함수 구현: FFT를 통한 로그 스펙트럼 계산, 복소로그 연산, IFFT를 통한 켑스트럼 계산. 입력 신호의 크기 스펙트럼에서 로그를 취하고 역변환하여 실켄셰번스 켑스트럼 도출. 0값 처리 및 수치 안정성 확보를 위한 epsilon 추가",
            "status": "done",
            "testStrategy": "알려진 신호에 대한 켑스트럼 계산 결과가 NumPy/SciPy의 scipy.signal.cepstrum과 일치하는지 검증"
          },
          {
            "id": 3,
            "title": "역 켑스트럼 변환 구현",
            "description": "envelope/cepstrum.c에서 켑스트럼에서 원본 신호로의 역변환을 구현합니다",
            "dependencies": [
              "8.2"
            ],
            "details": "vv_dsp_irceps 함수 구현: 켑스트럼 데이터를 받아 FFT 적용, 지수 함수를 통한 복원, IFFT로 원본 신호 복원. 실켄셰번스 켑스트럼의 역변환 과정으로 exp(FFT(cepstrum))을 계산하여 원본 스펙트럼 복원",
            "status": "done",
            "testStrategy": "rceps -> irceps 변환 과정에서 원본 신호의 크기 스펙트럼이 올바르게 복원되는지 검증"
          },
          {
            "id": 4,
            "title": "최소위상 변환 모듈 구현",
            "description": "envelope/minphase.c와 minphase.h 파일을 생성하고 최소위상 변환을 구현합니다",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "vv_dsp_minphase 함수 구현: 입력 신호의 크기 스펙트럼을 보존하면서 최소위상 특성을 갖도록 변환. 실켄셰번스 켑스트럼을 이용한 방법으로 켑스트럼의 causal 부분만 사용하여 최소위상 신호 생성. 위상 응답 최소화와 인과성 보장",
            "status": "done",
            "testStrategy": "최소위상 변환 후 크기 스펙트럼이 보존되고, 위상 응답이 최소위상 특성을 만족하는지 확인"
          },
          {
            "id": 5,
            "title": "위상 처리 유틸리티 및 통합 테스트",
            "description": "로그 스펙트럼 계산과 위상 언랩/랩 유틸리티를 구현하고 전체 모듈을 테스트합니다",
            "dependencies": [
              "8.4"
            ],
            "details": "로그 스펙트럼 계산 헬퍼 함수들과 위상 언랩핑/랩핑 기능 구현. phase_unwrap, phase_wrap 함수로 위상 연속성 처리. 켑스트럼과 최소위상 변환 모듈의 통합 테스트 작성. 각 함수의 메모리 할당/해제 확인 및 에러 처리 검증",
            "status": "done",
            "testStrategy": "전체 envelope 모듈의 기능 통합 테스트, 메모리 누수 검사, 실제 음성 신호에 대한 처리 성능 및 정확도 검증"
          }
        ]
      },
      {
        "id": 9,
        "title": "LPC 및 스펙트럴 엔벨로프 추정 구현",
        "description": "Levinson-Durbin 알고리즘과 LPC 계수를 이용한 스펙트럴 엔벨로프 추정을 구현합니다",
        "details": "envelope/lpc.h와 lpc.c에서 vv_dsp_levinson (Levinson-Durbin 알고리즘), vv_dsp_lpc (선형 예측 계수 계산), vv_dsp_lpspec (LPC 스펙트럼 추정) 함수 구현. 자기상관함수 계산과 예측 오차 최소화 알고리즘 포함",
        "testStrategy": "음성 신호의 LPC 분석 정확도 검증, 스펙트럴 엔벨로프 추정 품질 평가",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "LPC 헤더 파일 정의 및 기본 구조체 설계",
            "description": "envelope/lpc.h에서 LPC 관련 함수들의 선언과 데이터 구조를 정의합니다",
            "dependencies": [],
            "details": "envelope/lpc.h 파일에서 vv_dsp_levinson, vv_dsp_lpc, vv_dsp_lpspec 함수 선언과 매개변수 정의. LPC 계수를 저장할 구조체와 자기상관 함수 인터페이스 설계. vv_dsp_real, vv_dsp_status 타입 사용하여 일관된 API 구성. 함수들은 입력 신호, 출력 계수, 차수(order) 매개변수를 받도록 설계",
            "status": "done",
            "testStrategy": "헤더 파일이 올바르게 컴파일되고 타입 정의가 코어 모듈과 호환되는지 확인"
          },
          {
            "id": 2,
            "title": "자기상관 함수 계산 구현",
            "description": "입력 신호에서 자기상관 함수를 계산하는 vv_dsp_autocorr 함수를 구현합니다",
            "dependencies": [
              "9.1"
            ],
            "details": "envelope/lpc.c에서 vv_dsp_autocorr 함수 구현: 입력 신호 x[n]에서 R[k] = Σ x[n]x[n-k] (k=0,1,...,p) 계산. 효율적인 시간 영역 계산 또는 FFT 기반 방법 선택 가능. 바이어스/언바이어스 옵션 제공, 윈도우 길이에 따른 정규화 처리. 수치적 안정성을 위한 입력 검증과 오버플로우 방지",
            "status": "done",
            "testStrategy": "알려진 신호의 자기상관 함수가 NumPy의 numpy.correlate 결과와 일치하는지 검증"
          },
          {
            "id": 3,
            "title": "Levinson-Durbin 알고리즘 구현",
            "description": "자기상관 계수에서 LPC 계수를 구하는 Levinson-Durbin 알고리즘을 구현합니다",
            "dependencies": [
              "9.2"
            ],
            "details": "vv_dsp_levinson 함수로 자기상관 계수 R[0]...R[p]에서 LPC 계수 a[1]...a[p] 계산. 순환 알고리즘으로 각 차수별 반사 계수(reflection coefficient) k[i] 계산하고 필터 계수 갱신. 예측 오차 에너지 계산과 수치 안정성 확보. 특이값 처리와 발산 방지를 위한 조건 확인",
            "status": "done",
            "testStrategy": "Matlab/Octave의 levinson 함수나 scipy.signal.lfilter와 결과 비교, 수치적 안정성 테스트"
          },
          {
            "id": 4,
            "title": "LPC 계수 계산 및 예측 오차 분석",
            "description": "전체 LPC 분석을 수행하는 vv_dsp_lpc 함수와 예측 오차 계산을 구현합니다",
            "dependencies": [
              "9.3"
            ],
            "details": "vv_dsp_lpc 함수로 입력 신호에서 자기상관 계산 -> Levinson-Durbin -> LPC 계수 출력까지 통합 처리. 예측 오차(prediction error) 에너지와 반사 계수들 출력 옵션. 다양한 LPC 차수에 대한 최적 차수 선택 지원. 프리엠퍼시스(pre-emphasis) 필터 적용 옵션과 윈도우 함수 적용",
            "status": "done",
            "testStrategy": "음성 신호 샘플에 대한 LPC 분석 결과가 참조 구현(Matlab Signal Processing Toolbox 등)과 일치하는지 확인"
          },
          {
            "id": 5,
            "title": "LPC 스펙트럼 추정 및 모듈 통합",
            "description": "LPC 계수에서 스펙트럴 엔벨로프를 추정하는 vv_dsp_lpspec 함수를 구현하고 전체 모듈을 통합합니다",
            "dependencies": [
              "9.4"
            ],
            "details": "vv_dsp_lpspec 함수로 LPC 계수에서 H(ω) = G / (1 - Σa[k]e^(-jωk)) 주파수 응답 계산. FFT를 이용한 효율적인 스펙트럼 계산과 크기/위상 추출. 다양한 주파수 해상도 지원과 선택적 스펙트럴 스무딩. CMakeLists.txt에 LPC 모듈 추가, 전체 envelope 패키지 통합, 종합 테스트와 메모리 최적화 적용",
            "status": "done",
            "testStrategy": "LPC 스펙트럴 엔벨로프가 입력 신호의 스펙트럼 특성을 올바르게 근사하는지 검증, 음성 포만트 추정 정확도 평가"
          }
        ]
      },
      {
        "id": 10,
        "title": "C++ 래퍼 및 통합 테스트 시스템 구현",
        "description": "C++ RAII 래퍼와 포괄적인 테스트 슈트를 구현하여 라이브러리를 완성합니다",
        "details": "adapters/cpp_wrapper.hpp에서 모든 C 함수에 대한 RAII 기반 C++ 클래스 래퍼 구현. vv::dsp 네임스페이스 사용, span/strided view 지원. tests/ 디렉토리에서 각 모듈별 단위 테스트, 통합 테스트, 마이크로벤치마크 구현. NumPy/SciPy 참조값과 비교 검증\n<info added on 2025-08-10T15:37:09.098Z>\n<info added on 2024-07-30T10:00:00Z>\nNumPy/SciPy 수치 비교는 현재 C 테스트에 직접 통합되어 있지 않으며, 필요시 C 결과 내보내기 및 NumPy와의 심층 비교를 위한 선택적 Python 하네스(pytest) 추가를 제안합니다.\n</info added on 2024-07-30T10:00:00Z>\n</info added on 2025-08-10T15:37:09.098Z>",
        "testStrategy": "전체 라이브러리 기능의 정확도 검증, 성능 벤치마크, 메모리 누수 검사, 48kHz 실시간 처리 성능 확인",
        "priority": "medium",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "C++ RAII 래퍼 헤더 파일 구조 및 네임스페이스 정의",
            "description": "adapters/cpp_wrapper.hpp에서 vv::dsp 네임스페이스와 기본 C++ 클래스 구조를 정의합니다",
            "dependencies": [],
            "details": "adapters/cpp_wrapper.hpp 파일 생성하고 vv::dsp 네임스페이스 정의. 모든 C 헤더 파일들을 포함하고, C++ 표준 라이브러리(span, memory, vector) 포함. RAII 기반 클래스들의 기본 구조 정의 - FFTPlanner, STFTProcessor, WindowGenerator, Resampler 등 각 모듈별 래퍼 클래스. 예외 처리를 위한 DSPException 클래스 정의, vv_dsp_status를 C++ 예외로 변환하는 헬퍼 함수 구현",
            "status": "done",
            "testStrategy": "헤더 파일이 올바르게 컴파일되고 모든 C 함수들이 접근 가능한지 확인, C++ 표준 호환성 테스트"
          },
          {
            "id": 2,
            "title": "코어 모듈 C++ 래퍼 클래스 구현",
            "description": "코어 타입 시스템과 기본 수학 연산들에 대한 C++ 래퍼를 구현합니다",
            "dependencies": [
              "10.1"
            ],
            "details": "vv::dsp::Complex 클래스로 vv_dsp_cpx 래퍼 구현, 연산자 오버로딩(+, -, *, /) 제공. vv::dsp::Math 네임스페이스에 정적 함수들로 sum, mean, variance, min/max 래퍼. std::span<const Real> 또는 std::vector<Real>을 받는 템플릿 기반 인터페이스 구현. RAII 방식의 메모리 관리와 자동 타입 변환 지원. strided view를 위한 span 확장 인터페이스 제공",
            "status": "done",
            "testStrategy": "C++ STL 컨테이너와의 호환성 확인, 연산자 오버로딩 정확도 테스트, 메모리 관리 검증"
          },
          {
            "id": 3,
            "title": "스펙트럴 분석 모듈 C++ 래퍼 구현",
            "description": "FFT, STFT 등 스펙트럴 분석 기능들에 대한 RAII 기반 C++ 클래스를 구현합니다",
            "dependencies": [
              "10.2"
            ],
            "details": "vv::dsp::FFTPlanner 클래스로 vv_dsp_fft_plan 래퍼, 생성자에서 플랜 생성, 소멸자에서 자동 해제. forward/backward 메서드로 변환 수행, std::complex<Real> 배열과 호환. vv::dsp::STFT 클래스로 실시간 STFT 처리, process() 메서드로 프레임 단위 처리, overlap-add 기반 reconstruct() 구현. 템플릿 기반으로 다양한 컨테이너 타입 지원, 이동 의미론(move semantics) 활용",
            "status": "done",
            "testStrategy": "RAII 기반 자동 메모리 관리 확인, C++ 컨테이너 호환성 테스트, 실시간 처리 성능 검증"
          },
          {
            "id": 4,
            "title": "필터링 및 리샘플링 C++ 래퍼 구현",
            "description": "필터 설계, 리샘플링 등의 모듈에 대한 C++ 인터페이스를 구현합니다",
            "dependencies": [
              "10.3"
            ],
            "details": "vv::dsp::FIRFilter, vv::dsp::IIRFilter 클래스로 필터 상태 관리와 실시간 처리 제공. Resampler 클래스로 polyphase 리샘플러 래퍼, 생성자에서 비율 설정, process() 메서드로 스트리밍 처리. WindowGenerator 클래스로 다양한 윈도우 함수 생성, 팩토리 패턴 적용. 각 클래스는 C++ 이동 의미론과 복사 방지 구현, 상태 기반 실시간 처리 인터페이스 제공",
            "status": "done",
            "testStrategy": "필터 상태 관리 정확도 확인, 리샘플링 품질 테스트, 실시간 스트리밍 처리 성능 측정"
          },
          {
            "id": 5,
            "title": "포괄적 테스트 슈트 및 성능 벤치마크 구현",
            "description": "tests/ 디렉토리에 각 모듈별 단위 테스트, 통합 테스트, 마이크로벤치마크를 구현하고 NumPy/SciPy와 비교 검증합니다",
            "dependencies": [
              "10.4"
            ],
            "details": "tests/ 디렉토리 생성하고 Google Test 또는 Catch2 기반 테스트 프레임워크 설정. 각 모듈별 테스트 파일(test_core.cpp, test_fft.cpp, test_stft.cpp 등) 작성. NumPy/SciPy 참조 데이터와 비교하는 정확도 테스트, 메모리 누수 검사를 위한 Valgrind/AddressSanitizer 통합. 48kHz 실시간 처리 성능 벤치마크와 다양한 신호 길이에서의 처리 시간 측정. CMakeLists.txt에 테스트 타겟 추가, CI/CD 파이프라인 설정\n<info added on 2025-08-10T15:35:29.209Z>\n마이크로벤치마크 타겟 (vv-dsp-bench) 및 선택적 Sanitizer 지원 추가. `tests/bench_fft_stft.cpp` 파일에 FFT (C2C) 및 STFT (분석) 타이밍 벤치마크 (1000회 반복) 구현. `tests/CMakeLists.txt`에 `vv-dsp-bench` 타겟 추가 및 CTest 기본 비활성화. 루트 `CMakeLists.txt`에 `VV_DSP_ENABLE_ASAN`/`UBSAN` 옵션 및 컴파일/링크 옵션 연결, Valgrind memcheck 감지 로직 추가. 빌드 성공 및 새 타겟 확인. 기존 12개 테스트 모두 통과했으며, 벤치마크는 성능 변동성 방지를 위해 CTest에서 기본 비활성화됨.\n</info added on 2025-08-10T15:35:29.209Z>\n<info added on 2025-08-10T15:36:01.273Z>\nValgrind를 이용한 `ctest -T memcheck` 시도 결과, CTest memcheck가 DartConfiguration 및 메모리 체커 없이 구성되지 않음을 확인. 루트 CMake는 Valgrind 존재 시 `MemoryCheckCommand` 변수를 설정하지만, `ctest -T memcheck`는 대시보드 컨텍스트를 기대하며 추가 구성이 필요함. 대안으로 특정 타겟을 Valgrind로 수동 실행하거나, `-DVV_DSP_ENABLE_ASAN=ON` 옵션으로 ASan을 활성화하여 테스트를 재실행하는 방안을 고려 중.\n</info added on 2025-08-10T15:36:01.273Z>",
            "status": "done",
            "testStrategy": "전체 라이브러리 기능 정확도 검증, 메모리 누수 및 성능 회귀 검사, 실시간 처리 성능 확인, NumPy/SciPy와의 수치적 일치성 검증"
          }
        ]
      },
      {
        "id": 11,
        "title": "Add Python-based Verification Harness with NumPy/SciPy Integration",
        "description": "Implement a Python-based verification harness to compare vv-dsp outputs against NumPy/SciPy references and integrate it with CTest.",
        "details": "1.  **Directory Structure**: Create a `python/` directory at the project root. Inside, include a `requirements.txt` file specifying `numpy` and `scipy`. Optionally, provide a minimal `venv` bootstrap script for easy setup.\n2.  **Python Test Scripts**: Develop individual Python scripts within `python/` for each validation target:\n    *   `test_fft.py`: Validate FFT (C2C, R2C, C2R) outputs.\n    *   `test_filters.py`: Validate FIR and IIR filtering (including `filtfilt`).\n    *   `test_stft.py`: Validate STFT/ISTFT roundtrip accuracy.\n    *   `test_resampler.py`: Validate resampler frequency response.\n3.  **C-Python Interface**: For each DSP function to be tested, create a minimal C command-line interface (CLI) binary (e.g., `vv_dsp_dump_fft`, `vv_dsp_dump_filter`). These binaries should accept parameters (e.g., input size, filter coefficients) and output the processed data to standard output in a parseable format (e.g., space-separated floats, CSV, or raw binary for large arrays). Python scripts will then execute these binaries using `subprocess` and parse their output.\n4.  **CTest Integration**: Modify the main `CMakeLists.txt` to:\n    *   Find `Python3` and its `NumPy` and `SciPy` components.\n    *   Conditionally add tests using `add_test(NAME py-fft COMMAND ${Python3_EXECUTABLE} ${CMAKE_SOURCE_DIR}/python/test_fft.py)` for each Python script.\n    *   Ensure Python scripts return a non-zero exit code on failure and `sys.exit(77)` (CTest skip code) if Python or required libraries are not found.\n5.  **Tolerance Definition**: Define and document specific absolute and relative tolerances for numerical comparisons:\n    *   For `double` precision outputs: `atol=1e-6`, `rtol=1e-6`.\n    *   For `float` (single) precision outputs: `atol=1e-4`, `rtol=1e-4` (or appropriate values based on precision limits).\n6.  **Graceful Skipping**: Implement logic in Python scripts to check for `numpy` and `scipy` availability. If not found, print a message and exit with `sys.exit(77)` so CTest marks the test as `SKIP` instead of `FAIL`.",
        "testStrategy": "For each Python test script:\n1.  **Input Generation**: Generate small and medium-sized input signals (e.g., sine waves, impulses, random noise) covering various edge cases and typical usage scenarios.\n2.  **vv-dsp Execution**: Execute the corresponding `vv-dsp` C CLI binary with the generated input parameters to obtain the `vv-dsp` output.\n3.  **NumPy/SciPy Reference**: Perform the equivalent DSP operation using NumPy/SciPy functions to generate a reference output.\n4.  **Comparison**: Use `numpy.testing.assert_allclose` to compare the `vv-dsp` output against the NumPy/SciPy reference, applying the defined absolute and relative tolerances.\n5.  **Error Reporting**: Report the maximum absolute and relative errors observed during the comparison.\n6.  **Failure Condition**: The test must fail (return a non-zero exit code) if any comparison exceeds the predefined tolerances.\n7.  **CTest Verification**: Verify that CTest correctly executes the Python tests, reports success/failure based on the script's exit code, and marks tests as `SKIP` when Python or required libraries are unavailable.",
        "status": "done",
        "dependencies": [
          1,
          6,
          7,
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Add CI Plumbing for Python/NumPy Cross-Validation Tests",
        "description": "Implement the necessary CMake and CI configurations to integrate Python/NumPy cross-validation tests into the CTest matrix, making them opt-in and ensuring sanitizer compatibility.",
        "details": "1.  **CMake Integration:**\n    *   Utilize `FindPython3` to locate the Python interpreter and necessary libraries.\n    *   Employ `try_run` or `execute_process` to verify that `numpy` and `scipy` can be successfully imported. If import fails, ensure Python tests are disabled with a clear diagnostic message.\n    *   Define a new CMake option, `VERIFY_WITH_PYTHON` (defaulting to `OFF`), to control the inclusion and execution of Python-based tests.\n    *   For each Python test script defined in Task 11, add a custom CTest command using `add_test`.\n    *   Assign CTest labels `py` and `validation` to these newly added Python tests.\n    *   Ensure the CTest commands correctly invoke the Python scripts, passing any required arguments such as paths to `vv-dsp` CLI binaries or input/output directories.\n2.  **Sanitizer Compatibility:**\n    *   Investigate and address potential conflicts or performance impacts when running Python tests alongside ASan/UBSan builds.\n    *   If necessary, implement mechanisms (e.g., specific CMake flags, environment variables, or wrapper scripts) to selectively disable sanitizers for the `vv-dsp` CLI calls made by Python tests, or for the Python test runner itself, while prioritizing keeping sanitizers enabled for the core C/C++ code.\n3.  **Documentation:**\n    *   Update the `README.md` file with a dedicated section detailing the Python-based verification setup.\n    *   Clearly explain how to enable the `VERIFY_WITH_PYTHON` option via CMake.\n    *   Provide explicit instructions for installing the required Python dependencies (e.g., `pip install -r python/requirements.txt`).\n    *   Detail how to interpret test failures, including guidance on locating relevant logs and understanding numerical differences.\n4.  **CI Pipeline Configuration (Conceptual):**\n    *   Outline the steps required for a CI job to build `vv-dsp` with tests, enable `VERIFY_WITH_PYTHON`, install Python dependencies, and execute `ctest -L validation`.",
        "testStrategy": "1.  **Local Verification:**\n    *   Build the project locally with the `-DVERIFY_WITH_PYTHON=ON` CMake flag.\n    *   Verify that CMake correctly detects Python3, NumPy, and SciPy, and that the Python tests are configured.\n    *   Run `ctest -L validation` and confirm that the Python tests (from Task 11) are discovered, executed, and report their results correctly.\n    *   Test the scenario where `numpy` and/or `scipy` are *not* installed in the Python environment to ensure CMake correctly disables the Python tests and provides an informative message.\n    *   Build the project with ASan/UBSan enabled and run the Python tests to confirm no crashes, memory errors, or unexpected behavior occur.\n2.  **CI Pipeline Integration:**\n    *   Implement a dedicated CI pipeline job (or extend an existing one) that simulates the full CI workflow: building `vv-dsp` with tests, enabling `VERIFY_WITH_PYTHON`, installing `numpy`/`scipy` within a virtual environment, and executing `ctest -L validation`.\n    *   Verify that this CI job successfully passes when the Python tests pass, and correctly fails when they encounter issues.\n    *   Confirm that the CI output clearly indicates the execution of the Python tests and their respective outcomes.",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Discrete Cosine Transform (DCT)",
        "description": "Implement Discrete Cosine Transform (DCT-II/III) and optional DCT-IV for float/double arrays, with SIMD-friendly loops and plan caching similar to FFT.",
        "details": "Implement `vv_dsp_dct_forward` and `vv_dsp_dct_inverse` functions supporting DCT-II and DCT-III. Optionally, add support for DCT-IV. Functions should handle both `float` and `double` arrays. Design for SIMD-friendly loops to maximize performance and implement a plan caching mechanism similar to the existing FFT module. The implementation should not be restricted to power-of-two sizes. Investigate and, if feasible, reuse the existing FFT backend for DCT computation (e.g., via FFT-based DCT algorithms) to leverage existing optimizations and reduce code duplication. Document the complexity and numerical properties of the implemented DCT algorithms.",
        "testStrategy": "Develop comprehensive unit tests for roundtrip accuracy (forward then inverse transform should restore the original signal) and against known analytical vectors. Define and verify error thresholds comparable to those used for FFT paths. Cross-check outputs against a reliable reference: utilize the Python-based verification harness (Task 11) to compare against SciPy's DCT implementations, and for small sizes, implement a naive O(N^2) reference DCT for cross-validation. Conduct micro-benchmarks for various input sizes, specifically from 64 to 8192, and report time per operation. Integrate all tests (unit tests, reference validation, benchmarks) into the CTest framework.",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Chirp Z-Transform (CZT) Support",
        "description": "Implement the Chirp Z-Transform (CZT) to evaluate the z-transform on spiral arcs, including a convenience wrapper for zoomed spectrum analysis around target frequencies.",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "medium",
        "details": "Implemented the core CZT algorithm using Bluestein's algorithm, leveraging the existing FFT backend for convolution. The primary APIs are `vv_dsp_czt_exec_cpx` for complex inputs/outputs and `vv_dsp_czt_exec_real` for real inputs, with float and double precision overloads. These are defined in `include/vv_dsp/spectral/czt.h` and implemented in `src/spectral/czt.c`. A helper function, `vv_dsp_czt_params_for_freq_range(float f_start, float f_end, size_t M, float sampling_rate, float* W_real, float* W_imag, float* A_real, float* A_imag)`, has been provided to compute the `W` and `A` parameters for a specified frequency range and number of bins. Implementation details include careful zero-padding of input and chirp sequences to optimal FFT lengths (power-of-two), performing three FFTs (input*chirp, chirp, and inverse FFT of their product), element-wise multiplication in the frequency domain, and final multiplication by a chirp sequence, ensuring correct chirp construction and convolution alignment. Proper scaling is ensured throughout the process. The API is documented, and micro-benchmarks for performance analysis are provided.",
        "testStrategy": "Comprehensive unit tests and cross-validation tests have been developed. Unit tests in `tests/czt_tests.c` verify the `vv_dsp_czt_params_for_freq_range` helper for correct parameter generation and `vv_dsp_czt_exec_cpx`/`vv_dsp_czt_exec_real` for known analytical cases, specifically validating the DFT-equivalence case (A=1, W=exp(-j2pi/N), M=N). Cross-validation utilizes the Python-based verification harness (Task 11) via the `tools/dump_czt.c` CLI tool to compare `vv-dsp` outputs against `scipy.signal.czt`. The Python script `python/test_czt.py` performs cross-validation for random complex inputs and a zoomed frequency range on a real sinusoid. Various input signal types (random noise, sine waves, impulses, chirps) and different `N` (input length) and `M` (number of CZT points) are covered. A wide range of spiral arc parameters are tested, including arcs covering DC, Nyquist, arbitrary frequency ranges, and cases equivalent to DFT (full circles). Edge cases such as `M=1`, `M=N`, `M > N`, `M < N`, and `N=1` are included. Numerical accuracy (e.g., relative L2 norm error) is measured, and acceptable error thresholds are defined. For very small `M`, validation against a direct DFT implementation is used as a robust reference. All tests are integrated into CTest under labels `py;validation` and `vv-dsp-czt`, leveraging the CI plumbing for Python/NumPy cross-validation (Task 12). Micro-benchmarks for performance analysis for various `N` and `M` against SciPy (where feasible for cross-language comparison) are documented.",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Extended Window Functions (Flattop, Kaiser, Tukey, etc.)",
        "description": "Extend the library's window function coverage by implementing additional variants like flattop, kaiser, tukey, bartlett, bohman, cosine, and planck-taper, ensuring parameterized APIs and comprehensive testing against SciPy.",
        "details": "Implement the specified window functions (flattop, kaiser, tukey, bartlett, bohman, cosine, planck-taper) within `window.c`. Each function should support parameterized APIs where applicable (e.g., `vv_dsp_window_kaiser(size_t N, double beta, float* output)` for float and double variants). Ensure both single (`float`) and double (`double`) precision variants are implemented for all new window functions, adhering to existing library policy. Update `window.h` with new function declarations and document the new window functions, their parameters, and characteristics in the project's documentation. Consider edge cases for small `N` values (e.g., `N=1`, `N=2`).",
        "testStrategy": "Develop comprehensive unit tests for each new window function. Utilize the Python-based verification harness (Task 11) to compare the generated window coefficients against `scipy.signal` equivalents (e.g., `scipy.signal.windows.kaiser`, `scipy.signal.windows.flattop`) within defined numerical tolerances. Specifically document any known differences in end-point handling or normalization between `vv-dsp` and SciPy implementations. For small `N` values, verify against pre-computed \"golden values\". Implement statistical checks for key window properties such as Equivalent Noise Bandwidth (ENBW) and scalloping loss, comparing them against known theoretical or reference values. Ensure tests cover various parameter values (e.g., different `beta` for Kaiser, `alpha` for Tukey). Verify symmetry and normalization properties of the generated windows.",
        "status": "pending",
        "dependencies": [
          3,
          11,
          12
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Non-Parameterized Window Functions",
            "description": "Implement the `bartlett`, `bohman`, `cosine`, and `planck-taper` window functions. Each function must have both single (`float`) and double (`double`) precision variants.",
            "dependencies": [],
            "details": "Implement `vv_dsp_window_bartlett_f/d`, `vv_dsp_window_bohman_f/d`, `vv_dsp_window_cosine_f/d`, and `vv_dsp_window_planck_taper_f/d` in `src/dsp/window.c`. Adhere to the existing function signature pattern `void vv_dsp_window_<name>_f(size_t N, float* output)`. Ensure proper handling of edge cases for `N=0` (return immediately) and `N=1` (output[0] = 1.0f).",
            "status": "pending",
            "testStrategy": "Initial manual verification of small N values (e.g., N=2, N=3) to ensure basic correctness before comprehensive testing."
          },
          {
            "id": 2,
            "title": "Implement Parameterized Window Functions",
            "description": "Implement the `flattop`, `kaiser`, and `tukey` window functions, supporting their respective parameters. Each function must have both single (`float`) and double (`double`) precision variants.",
            "dependencies": [],
            "details": "Implement `vv_dsp_window_flattop_f/d`, `vv_dsp_window_kaiser_f/d`, and `vv_dsp_window_tukey_f/d` in `src/dsp/window.c`. The function signatures should include the relevant parameter, e.g., `void vv_dsp_window_kaiser_f(size_t N, double beta, float* output)`. Ensure proper handling of edge cases for `N=0` (return immediately) and `N=1` (output[0] = 1.0f). Research the specific parameter definitions for each window (e.g., Kaiser's beta, Tukey's alpha) to ensure correct implementation.",
            "status": "pending",
            "testStrategy": "Initial manual verification with common parameter values and small N to check for obvious errors."
          },
          {
            "id": 3,
            "title": "Update Header Declarations and Project Documentation",
            "description": "Add declarations for all newly implemented window functions to `include/vv_dsp/dsp/window.h` and update the project's documentation with details on each new window function.",
            "dependencies": [
              "15.1",
              "15.2"
            ],
            "details": "For each new window function (bartlett, bohman, cosine, planck-taper, flattop, kaiser, tukey), add its `_f` and `_d` declarations to `include/vv_dsp/dsp/window.h`, following the existing style and order. Additionally, update the project's documentation (e.g., a dedicated `docs/` section or markdown file) to describe each new window function, its purpose, parameters, and any specific characteristics or common use cases.",
            "status": "pending",
            "testStrategy": "Compile the library to ensure no header conflicts or missing declarations. Review documentation for clarity and completeness."
          },
          {
            "id": 4,
            "title": "Develop Unit Tests for Non-Parameterized Window Functions",
            "description": "Create comprehensive unit tests for the `bartlett`, `bohman`, `cosine`, and `planck-taper` window functions.",
            "dependencies": [
              "15.1",
              "15.3"
            ],
            "details": "Add new `TEST_CASE` blocks to `tests/dsp/window_tests.c` for each of the non-parameterized window functions. For each function, include tests for both `float` and `double` precision variants. Test various `N` values, including `N=1`, `N=2`, and typical larger sizes (e.g., 10, 64, 128). Utilize the Python-based verification harness (Task 11) to generate reference data from `scipy.signal.windows` for numerical comparison, ensuring results are within defined numerical tolerances.",
            "status": "pending",
            "testStrategy": "Run `ctest` to execute all new window tests. Verify that all tests pass and that numerical accuracy meets expectations against SciPy references."
          },
          {
            "id": 5,
            "title": "Develop Unit Tests for Parameterized Window Functions",
            "description": "Create comprehensive unit tests for the `flattop`, `kaiser`, and `tukey` window functions, covering various parameter values.",
            "dependencies": [
              "15.2",
              "15.3"
            ],
            "details": "Add new `TEST_CASE` blocks to `tests/dsp/window_tests.c` for each of the parameterized window functions. For each function, include tests for both `float` and `double` precision variants. Test various `N` values (including `N=1`, `N=2`, and typical larger sizes) and, critically, test with multiple representative parameter values (e.g., different `beta` values for Kaiser, different `alpha` values for Tukey). Utilize the Python-based verification harness (Task 11) to generate reference data from `scipy.signal.windows` for numerical comparison, ensuring results are within defined numerical tolerances.",
            "status": "pending",
            "testStrategy": "Run `ctest` to execute all new window tests. Pay close attention to tests with varying parameters to ensure correct behavior across the parameter range. Verify numerical accuracy against SciPy references."
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement Basic Signal Statistics and Measurement Utilities",
        "description": "Implement a suite of basic signal statistics and measurement utilities including RMS, peak, crest factor, zero-crossing rate, skewness, kurtosis, autocorrelation, and cross-correlation, supporting both float and double precision arrays.",
        "details": "Implement a new module, likely `core/stats.h` and `core/stats.c`, to house the signal statistics functions. Each function should support both `float` and `double` precision variants.\n\nSpecific functions to implement:\n- `vv_dsp_rms(const float* data, size_t N)`: Root Mean Square.\n- `vv_dsp_peak(const float* data, size_t N, float* min_val, float* max_val)`: Returns min and max values.\n- `vv_dsp_crest_factor(const float* data, size_t N)`: Peak value divided by RMS value.\n- `vv_dsp_zero_crossing_rate(const float* data, size_t N)`: Number of times the signal crosses zero.\n- `vv_dsp_skewness(const float* data, size_t N)`: Measure of the asymmetry of the probability distribution.\n- `vv_dsp_kurtosis(const float* data, size_t N)`: Measure of the 'tailedness' of the probability distribution.\n- `vv_dsp_autocorrelation(const float* data, size_t N, float* output, size_t output_len, bool biased)`: Autocorrelation function, with options for biased/unbiased normalization. Consider direct computation for smaller N and potentially FFT-based for larger N if performance is critical.\n- `vv_dsp_cross_correlation(const float* data1, const float* data2, size_t N1, size_t N2, float* output, size_t output_len)`: Cross-correlation function.\n\nImplementation considerations:\n- Utilize numerically stable one-pass algorithms (e.g., Welford's method for mean, variance, and higher moments) where applicable for skewness and kurtosis to ensure accuracy.\n- Handle edge cases gracefully: empty arrays (N=0), constant signals, signals containing NaN or Inf values. Define expected behavior (e.g., return NaN, 0, or an error code).\n- Ensure proper memory management for output arrays in correlation functions.\n- Adhere to existing library coding standards and API conventions.\n<info added on 2025-08-11T05:11:52.440Z>\n**Progress Update:**\n- All specified signal statistics and measurement utilities (RMS, peak, crest factor, zero-crossing rate, skewness, kurtosis, autocorrelation, and cross-correlation) have been implemented in `src/core/stats.c`.\n- The public API for these functions has been defined in `include/vv_dsp/core.h`.\n- The new `stats.c` module has been successfully integrated into the build system by adding it to `src/core/CMakeLists.txt`.\n- Initial unit tests covering basic behavior and sanity checks have been added to `tests/core_tests.c`.\n- All current CTest unit tests for these utilities have passed.\n\n**Next Steps/Considerations:**\n- Investigate and potentially implement FFT-based fast correlation for `vv_dsp_autocorrelation` and `vv_dsp_cross_correlation` for large input sizes to improve performance.\n- Develop and integrate the Python-based cross-validation harness (leveraging Task 11) to compare results against `scipy.stats` and `numpy.correlate` for robust verification of numerical accuracy.\n</info added on 2025-08-11T05:11:52.440Z>",
        "testStrategy": "Develop comprehensive unit tests for each implemented function using CTest.\n\nSpecific test cases for each function:\n- **Basic Verification**: Test with small, hand-calculated examples to verify correctness.\n- **Edge Cases**: \n    - Empty arrays (N=0).\n    - Constant signals (e.g., `[5.0, 5.0, 5.0]`).\n    - Signals with all zeros or all ones.\n    - Signals containing `NaN` or `Inf` values (ensure graceful handling).\n    - Single-element arrays.\n- **Synthetic Signals**: Test with various synthetic signals such as sine waves, square waves, impulses, and random noise.\n- **Numerical Stability**: For skewness and kurtosis, verify results against known values for large datasets to confirm numerical stability.\n- **Cross-Validation**: Utilize the Python-based verification harness (Task 11) to cross-check results against `scipy.stats` (for skewness, kurtosis, RMS, etc.) and `numpy.correlate` or `scipy.signal.correlate` (for autocorrelation and cross-correlation). Define acceptable numerical tolerances for floating-point comparisons.\n- **Golden Vectors**: Generate and use golden vectors (pre-computed results for specific inputs) to ensure consistent behavior across different environments and future changes.",
        "status": "done",
        "dependencies": [
          11,
          12
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement WAV Audio File I/O Utilities",
        "description": "Implement utilities for reading and writing WAV audio files, supporting common formats (16-bit PCM, 24-bit packed, 32-bit float), with an optional libsndfile integration, controlled by a VV_DSP_ENABLE_AUDIO_IO build option.",
        "details": "Create a new module, e.g., `audio/vv_dsp_wav.h` and `audio/vv_dsp_wav.c`, to encapsulate WAV file I/O functionality.\n\nDefine the following core functions:\n- `vv_dsp_wav_read(const char* filepath, vv_dsp_real** out_buffer, size_t* out_num_samples, int* out_num_channels, double* out_sample_rate, int* out_bit_depth)`: Reads a WAV file into a planar `vv_dsp_real` buffer, returning metadata.\n- `vv_dsp_wav_write(const char* filepath, const vv_dsp_real* in_buffer, size_t num_samples, int num_channels, double sample_rate, int bit_depth)`: Writes a planar `vv_dsp_real` buffer to a WAV file with specified metadata.\n\n**Format Support:**\n- Implement robust support for reading and writing 16-bit PCM, 24-bit packed PCM, and 32-bit float WAV formats.\n- Handle conversion between the interleaved sample data typically found in WAV files and the planar `vv_dsp_real` buffer format used internally by `vv-dsp`. This involves de-interleaving on read and interleaving on write.\n\n**Optional `libsndfile` Shim:**\n- Introduce a CMake build option `VV_DSP_ENABLE_AUDIO_IO` (defaulting to `OFF`).\n- If `VV_DSP_ENABLE_AUDIO_IO` is `ON`, attempt to find and link against `libsndfile`.\n- If `libsndfile` is successfully found, use it as the backend for `vv_dsp_wav_read` and `vv_dsp_wav_write`.\n- If `libsndfile` is not found or `VV_DSP_ENABLE_AUDIO_IO` is `OFF`, implement a minimal, custom WAV parser/writer for the specified formats. This custom implementation should be robust enough for the target formats but does not need to be a full-featured WAV library.\n\n**Error Handling:**\n- Utilize `vv_dsp_status` for reporting success, failure, and specific error conditions (e.g., file not found, unsupported format, memory allocation failure, invalid parameters).\n\n**CMake Integration:**\n- Update `CMakeLists.txt` to include the new `audio` module.\n- Properly manage the `VV_DSP_ENABLE_AUDIO_IO` option and the conditional `libsndfile` dependency and linking.",
        "testStrategy": "Develop a comprehensive `CTest` suite for WAV I/O functionality.\n\n**Unit Tests:**\n- Test `vv_dsp_wav_read` with various valid WAV files (16-bit, 24-bit, 32-bit float, mono, stereo) from a dedicated `voicebank/fixtures` directory. Verify correct parsing of sample rate, channel count, bit depth, and total samples.\n- Test `vv_dsp_wav_write` by writing simple generated signals (e.g., sine wave, impulse, white noise) to temporary WAV files in all supported formats and channel configurations.\n\n**Roundtrip Tests:**\n- For each supported format (16-bit PCM, 24-bit packed, 32-bit float) and channel configuration (mono, stereo):\n    1.  Generate a short, known test signal (e.g., 1-second sine wave at 440 Hz, or a short burst of white noise).\n    2.  Write the original signal to a temporary WAV file using `vv_dsp_wav_write`.\n    3.  Read the temporary WAV file back into memory using `vv_dsp_wav_read`.\n    4.  Compare the original buffer with the read buffer:\n        - Verify that all metadata (sample rate, channels, bit depth) matches.\n        - Compare the content of the buffers. For integer formats, a bit-exact comparison or hash comparison (e.g., MD5 or simple checksum) of the raw sample data should be performed. For float formats, a sample-by-sample comparison with a small numerical tolerance is required.\n- Perform roundtrip tests using existing `voicebank/` fixtures if they are suitable and available.\n\n**Edge Cases and Error Handling:**\n- Test with non-existent files, files with invalid or corrupted headers (if custom parser is used), and very short or empty audio clips to ensure robust error handling.\n\n**Conditional Testing:**\n- Ensure all tests run correctly and pass when `VV_DSP_ENABLE_AUDIO_IO` is `ON` (both with and without `libsndfile` present) and when it is `OFF` (relying solely on the custom implementation). This may require separate CI configurations or conditional test execution.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Module Scaffolding and Public API",
            "description": "Create `include/vv_dsp/audio/wav.h` and `src/audio/wav.c`. Define public API: vv_dsp_wav_read, vv_dsp_wav_write, vv_dsp_wav_info; use vv_dsp_status and vv_dsp_real; planar channel buffers API.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 2,
            "title": "CMake Integration and Build Option",
            "description": "Add CMake option VV_DSP_ENABLE_AUDIO_IO (OFF by default). Conditionally add src/audio to build, install headers, and wire tests/examples under this option.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 3,
            "title": "Custom WAV Parser (Read-side)",
            "description": "Implement minimal custom WAV parser: parse RIFF/WAVE, fmt, data, optional chunks; support PCM16, packed PCM24, float32; validate headers; store channels, sample_rate, bit_depth, frames.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 4,
            "title": "Read Path: Deinterleave and Convert",
            "description": "Implement streaming-safe read: deinterleave interleaved samples into planar vv_dsp_real buffers; convert PCM16/PCM24/float32 to vv_dsp_real with proper scaling; support partial reads and large files.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 5,
            "title": "Write Path: Interleave and Emit",
            "description": "Implement writer: interleave planar buffers, emit WAV headers, support PCM16, packed PCM24, float32; dithering/truncation for integer formats; correct chunk sizes and alignment.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 6,
            "title": "Optional libsndfile Adapter",
            "description": "Optional libsndfile backend: add CMake find_package and link; when available, implement alternate code path with identical public API and runtime selection.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 7,
            "title": "Robust Error Handling and Cleanup",
            "description": "Map all I/O and format errors to vv_dsp_status codes; add helper for human-readable messages; ensure resource cleanup on failure paths.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          },
          {
            "id": 8,
            "title": "Tests and Example Utility",
            "description": "Add CTest roundtrip tests across formats/channels; fuzz/sanitizer-friendly cases; add basic CLI/example utility for manual smoke tests.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 17
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement Hilbert Transform and Analytic Signal Utilities",
        "description": "Implement core Hilbert Transform and Analytic Signal utilities, along with helper functions for instantaneous amplitude, phase, and frequency.",
        "details": "Implement the following functions:\n- `vv_dsp_hilbert_analytic(const vv_dsp_real* input, size_t N, vv_dsp_cpx* analytic_output)`: Computes the analytic signal of a real-valued input. The primary implementation should use the FFT method:\n    1. Perform FFT on the real input signal.\n    2. Construct a frequency-domain Hilbert transform filter: `H[0]=1`, `H[k]=2` for positive frequencies (`1 <= k < N/2`), `H[N/2]=1` (if N is even, Nyquist component), and `H[k]=0` for negative frequencies (`N/2 < k < N`).\n    3. Multiply the FFT output by this filter.\n    4. Perform IFFT to obtain the complex analytic signal. Ensure correct handling of even/odd N and scaling conventions.\n    5. Consider a fallback O(N^2) direct convolution for very small N if FFT overhead is prohibitive, but prioritize the FFT method.\n- `vv_dsp_instantaneous_phase(const vv_dsp_cpx* analytic_input, size_t N, vv_dsp_real* phase_output)`: Calculates the instantaneous phase from the complex analytic signal. This involves `atan2(imag, real)` followed by robust phase unwrapping to ensure continuity.\n- `vv_dsp_instantaneous_frequency(const vv_dsp_real* unwrapped_phase_input, size_t N, double sample_rate, vv_dsp_real* freq_output)`: Computes the instantaneous frequency from the unwrapped phase. This is typically derived from the discrete derivative of the unwrapped phase, scaled by `sample_rate / (2 * PI)`.",
        "testStrategy": "Develop comprehensive unit tests and cross-validation tests.\n\n**Unit Tests:**\n- **Signal Types**: Test with pure sinusoids, amplitude-modulated (AM) signals, and frequency-modulated (FM) chirps. Verify that `vv_dsp_hilbert_analytic` produces the expected complex signal (original real part, Hilbert transformed imaginary part).\n- **Instantaneous Helpers**: For AM/FM signals, verify that `vv_dsp_instantaneous_phase` accurately unwraps the phase and `vv_dsp_instantaneous_frequency` correctly tracks the instantaneous frequency against known analytical solutions.\n- **Edge Cases**: Test with signals containing DC offset, constant signals, signals with varying lengths (even/odd N), and very short signals.\n- **Numerical Accuracy**: Define and verify against acceptable numerical tolerances (e.g., `1e-6` for float, `1e-12` for double).\n\n**Cross-Validation (using Task 11 harness):**\n- Utilize the Python-based verification harness to compare the output of `vv_dsp_hilbert_analytic` against `scipy.signal.hilbert` for a diverse set of signals (e.g., sinusoids, noise, real-world audio snippets).\n- Ensure consistency in scaling and phase conventions between the C implementation and SciPy reference.\n- Integrate these tests into the CTest suite via the Task 12 CI plumbing.",
        "status": "pending",
        "dependencies": [
          2,
          4,
          11,
          12
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Module Setup and `vv_dsp_hilbert_analytic` Skeleton",
            "description": "Create the necessary header and source files for the Hilbert transform module. Define the `vv_dsp_hilbert_analytic` function signature and implement basic input validation. Set up the framework for FFT plan creation and destruction, and allocate temporary buffers required for the frequency domain operations.",
            "dependencies": [],
            "details": "1. Create `include/vv_dsp/spectral/hilbert.h` and `src/spectral/hilbert.c`.\n2. Include `vv_dsp/types.h`, `vv_dsp/spectral/fft.h`, and `vv_dsp/math/complex.h`.\n3. Define the `vv_dsp_hilbert_analytic` function signature: `int vv_dsp_hilbert_analytic(const vv_dsp_real* input, size_t N, vv_dsp_cpx* analytic_output)`.\n4. Implement initial input validation (e.g., `input`, `analytic_output` not NULL, `N > 0`).\n5. Integrate `vv_dsp_fft_plan_create` for real-to-complex FFT and complex-to-complex IFFT, and `vv_dsp_fft_plan_destroy`.\n6. Allocate dynamic memory for intermediate complex arrays (e.g., FFT output, filtered spectrum) using `vv_dsp_malloc` and `vv_dsp_free`.",
            "status": "pending",
            "testStrategy": "Basic unit tests to ensure function can be called without crashing and handles invalid inputs gracefully (e.g., NULL pointers, N=0)."
          },
          {
            "id": 2,
            "title": "Implement Core `vv_dsp_hilbert_analytic` (FFT Filtering)",
            "description": "Implement the primary FFT-based method for computing the analytic signal. This involves performing a real-to-complex FFT, constructing and applying the frequency-domain Hilbert filter, and then performing a complex-to-complex IFFT.",
            "dependencies": [],
            "details": "1. Execute a real-to-complex FFT on the `input` signal using `vv_dsp_fft_execute`.\n2. Construct the frequency-domain Hilbert transform filter `H`:\n    - `H[0] = 1`\n    - `H[k] = 2` for `1 <= k < N/2`\n    - `H[N/2] = 1` (if `N` is even, for the Nyquist component)\n    - `H[k] = 0` for `N/2 < k < N` (negative frequencies).\n3. Perform element-wise complex multiplication of the FFT output with the constructed filter `H`.\n4. Execute a complex-to-complex IFFT on the filtered spectrum to obtain the `analytic_output`.\n5. Ensure correct scaling of the IFFT output based on the FFT library's conventions (e.g., divide by `N`).\n6. The O(N^2) direct convolution fallback is considered a future enhancement; focus solely on the FFT method for this subtask.",
            "status": "pending",
            "testStrategy": "Unit tests with simple sinusoids (e.g., `sin(2*pi*f*t)`) to verify that the real part of the output matches the input and the imaginary part is a 90-degree phase-shifted version. Test with various `N` values (even/odd, small/medium)."
          },
          {
            "id": 3,
            "title": "Implement `vv_dsp_instantaneous_phase` with Robust Unwrapping",
            "description": "Implement the function to calculate the instantaneous phase from a complex analytic signal, including a robust phase unwrapping algorithm to ensure continuity.",
            "dependencies": [],
            "details": "1. Define the `vv_dsp_instantaneous_phase` function signature: `int vv_dsp_instantaneous_phase(const vv_dsp_cpx* analytic_input, size_t N, vv_dsp_real* phase_output)`.\n2. For each sample `i` from `0` to `N-1`, calculate the principal value of the phase using `atan2(analytic_input[i].imag, analytic_input[i].real)` and store it in `phase_output[i]`.\n3. Implement a robust phase unwrapping algorithm. A common approach is to iterate through the `phase_output` array, detect jumps greater than `PI` (or less than `-PI`), and add/subtract multiples of `2*PI` to subsequent samples to maintain continuity.",
            "status": "pending",
            "testStrategy": "Unit tests for `vv_dsp_instantaneous_phase`:\n- Test with a simple sinusoid to verify correct phase calculation.\n- Test with a signal whose phase crosses the `+/- PI` boundary multiple times to ensure robust unwrapping (e.g., a linearly increasing phase that wraps around)."
          },
          {
            "id": 4,
            "title": "Implement `vv_dsp_instantaneous_frequency`",
            "description": "Implement the function to compute the instantaneous frequency from an unwrapped phase signal, derived from its discrete derivative.",
            "dependencies": [],
            "details": "1. Define the `vv_dsp_instantaneous_frequency` function signature: `int vv_dsp_instantaneous_frequency(const vv_dsp_real* unwrapped_phase_input, size_t N, double sample_rate, vv_dsp_real* freq_output)`.\n2. For `i = 0`, set `freq_output[0]` to 0 or handle appropriately (e.g., copy `freq_output[1]`).\n3. For `i` from `1` to `N-1`, calculate the discrete derivative: `delta_phase = unwrapped_phase_input[i] - unwrapped_phase_input[i-1]`.\n4. Scale the `delta_phase` by `sample_rate / (2 * PI)` to convert from radians/sample to Hz: `freq_output[i] = delta_phase * (sample_rate / (2.0 * M_PI))` (assuming `M_PI` is available from `math.h`).",
            "status": "pending",
            "testStrategy": "Unit tests for `vv_dsp_instantaneous_frequency`:\n- Test with a signal having a constant frequency (linear unwrapped phase) to verify constant frequency output.\n- Test with a chirp signal (quadratic unwrapped phase) to verify linearly increasing/decreasing frequency output."
          },
          {
            "id": 5,
            "title": "Comprehensive Unit Testing and Integration",
            "description": "Develop and integrate comprehensive unit tests for all implemented Hilbert transform and analytic signal utility functions, covering various signal types, edge cases, and numerical accuracy.",
            "dependencies": [],
            "details": "1. Create `tests/hilbert_tests.c` following the existing CTest and `vv_dsp` testing patterns (e.g., `fft_tests.c`, `czt_tests.c`).\n2. Implement unit tests for `vv_dsp_hilbert_analytic`:\n    - Test with pure sinusoids (e.g., `sin(t)`, `cos(t)`) to verify real and imaginary parts.\n    - Test with amplitude-modulated (AM) signals.\n    - Test with frequency-modulated (FM) chirps.\n    - Verify correct handling of `N` (even/odd, small values like 1, 2, 3, 4).\n    - Check scaling and numerical accuracy against expected analytical results.\n3. Implement unit tests for `vv_dsp_instantaneous_phase`:\n    - Test with signals that cause phase wrapping and verify unwrapping correctness.\n    - Test with noisy signals to assess robustness.\n4. Implement unit tests for `vv_dsp_instantaneous_frequency`:\n    - Test with signals having known instantaneous frequencies (e.g., constant frequency, linear chirp).\n    - Verify the output frequency values are accurate.\n5. Add the new test file to the CTest build system (e.g., `CMakeLists.txt`).",
            "status": "pending",
            "testStrategy": "Utilize CTest for automated testing. Define acceptable error thresholds for numerical comparisons. Cross-validate results against known analytical solutions or established DSP libraries if available (e.g., SciPy's `hilbert` function for reference)."
          }
        ]
      },
      {
        "id": 19,
        "title": "Implement Savitzky–Golay Filter Utilities",
        "description": "Implement Savitzky–Golay smoothing and differentiation filter utilities, including kernel precomputation and robust parameter validation.",
        "details": "Create a new module, `filter/savgol.h` and `filter/savgol.c`, to encapsulate the Savitzky–Golay filter functionality. The primary API will be `vv_dsp_savgol(const vv_dsp_real* y, size_t N, int window_length, int polyorder, int deriv, vv_dsp_real delta, vv_dsp_savgol_mode mode, vv_dsp_real* output)`. \n\nImplementation steps:\n1.  **Input Validation**: Validate parameters: `window_length` must be odd and greater than `polyorder`. `polyorder` must be non-negative. `deriv` must be non-negative and less than or equal to `polyorder`. `window_length` must be less than or equal to `N`. Handle invalid inputs gracefully (e.g., return an error status).\n2.  **Kernel Precomputation**: Implement the logic to compute the Savitzky–Golay convolution kernels based on `window_length`, `polyorder`, and `deriv`. This typically involves solving a least-squares problem (e.g., using the pseudo-inverse of a Vandermonde matrix).\n3.  **Convolution**: Apply the precomputed kernel as a convolution to the input signal `y`.\n4.  **Edge Handling**: Implement boundary condition handling using the specified `mode` (e.g., `vv_dsp_savgol_mode_reflect` for symmetric extension, similar to SciPy's 'reflect' mode). This involves appropriately padding the input signal before convolution.\n5.  **Derivative Scaling**: Apply the `delta` scaling factor for differentiation (e.g., `output[i] *= (1.0 / pow(delta, deriv))`).\n6.  Ensure support for both `float` and `double` precision via `vv_dsp_real`.",
        "testStrategy": "Develop comprehensive unit tests for `vv_dsp_savgol` using CTest, focusing on numerical parity and accuracy.\n\n**Unit Tests:**\n-   **Basic Functionality**: Test with simple, analytically predictable signals (e.g., constant, linear, quadratic, cubic polynomials) to verify correct smoothing and differentiation for `deriv=0, 1, 2`.\n-   **Numerical Parity with SciPy**: Utilize a Python-based verification harness (if available, otherwise manual comparison) to compare `vv_dsp_savgol` output against `scipy.signal.savgol_filter` for:\n    -   Randomly generated signals of various lengths (small, medium, large).\n    -   Signals with known polynomial components.\n    -   A range of `window_length`, `polyorder`, `deriv` (0, 1, 2), and `delta` values.\n    -   Verify behavior for `mode=vv_dsp_savgol_mode_reflect`.\n-   **Derivative Accuracy**: For known polynomial signals, verify that `deriv=1` and `deriv=2` produce the correct analytical derivatives within a defined tolerance.\n-   **Edge Cases**: \n    -   `window_length` equal to `N` (signal length).\n    -   `window_length` just greater than `polyorder`.\n    -   `polyorder = 0` (equivalent to a moving average).\n    -   `deriv = 0` (smoothing only).\n    -   `deriv` equal to `polyorder` (highest possible derivative).\n    -   Input signal length `N` smaller than `window_length` (should return error).\n    -   Empty input signal (N=0).\n    -   Various `delta` values.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Module Setup and Initial Input Validation for Savitzky-Golay",
            "description": "Create the new module files `include/vv_dsp/filter/savgol.h` and `src/filter/savgol.c`. Define the `vv_dsp_savgol_mode` enum to specify boundary handling (e.g., `VV_DSP_SAVGOL_MODE_REFLECT`, `VV_DSP_SAVGOL_MODE_CONSTANT`, `VV_DSP_SAVGOL_MODE_NEAREST`, `VV_DSP_SAVGOL_MODE_WRAP`). Declare the primary `vv_dsp_savgol` function in the header. Implement the function skeleton in the C file, ensuring it returns `vv_dsp_status`. Implement all specified input validation checks: `window_length` must be odd and greater than `polyorder`, `polyorder` must be non-negative, `deriv` must be non-negative and less than or equal to `polyorder`, and `window_length` must be less than or equal to `N`. Return `VV_DSP_ERROR_INVALID_ARGUMENT` for any invalid inputs, consistent with `vv_dsp_status` error handling patterns found in `include/vv_dsp/common.h` and existing filter modules.",
            "dependencies": [],
            "details": "Add `savgol.c` to `src/filter/CMakeLists.txt` to ensure it's part of the build. Use `vv_dsp_real` for all floating-point parameters and calculations. Ensure the `vv_dsp_savgol_mode` enum is clearly defined with appropriate values for different boundary conditions.",
            "status": "pending",
            "testStrategy": "Write basic unit tests to verify that `vv_dsp_savgol` correctly identifies and returns `VV_DSP_ERROR_INVALID_ARGUMENT` for various invalid parameter combinations (e.g., even `window_length`, `polyorder` < 0, `deriv` > `polyorder`, `window_length` > `N`)."
          },
          {
            "id": 2,
            "title": "Implement Savitzky-Golay Kernel Precomputation",
            "description": "Develop the core logic to compute the Savitzky-Golay convolution kernel. This involves implementing necessary basic matrix operations (e.g., matrix multiplication, transpose, and pseudo-inverse calculation, potentially via QR decomposition or direct formula for small matrices) as helper functions within `savgol.c`. The kernel computation itself will involve constructing the Vandermonde matrix based on `window_length` and `polyorder`, computing its pseudo-inverse, and then extracting the coefficients corresponding to the specified `deriv` order. All matrix operations and coefficient calculations must use `vv_dsp_real`.",
            "dependencies": [
              "19.1"
            ],
            "details": "Given the absence of a dedicated matrix library in the codebase, these matrix operations will need to be implemented from scratch within `savgol.c` or as static helper functions. Focus on numerical stability for the pseudo-inverse calculation. Consider the specific formula for Savitzky-Golay coefficients derived from the pseudo-inverse of the Vandermonde matrix. Memory for temporary matrices should be managed using `vv_dsp_malloc` and `vv_dsp_free`.",
            "status": "pending",
            "testStrategy": "Create isolated unit tests for the kernel precomputation logic. Verify the generated kernels for simple cases (e.g., `window_length=5, polyorder=2, deriv=0` for smoothing, and `deriv=1` for differentiation) against known reference values (e.g., from SciPy's `savgol_filter` or analytical derivations)."
          },
          {
            "id": 3,
            "title": "Core Convolution and Derivative Scaling",
            "description": "Implement the central convolution algorithm that applies the precomputed Savitzky-Golay kernel to the input signal `y`. This subtask should focus on the 'valid' part of the convolution, assuming that any necessary padding for edge handling will be applied to the input signal before this step. After convolution, apply the `delta` scaling factor for differentiation, where `output[i] *= (1.0 / pow(delta, deriv))`. Ensure all calculations are performed using `vv_dsp_real`.",
            "dependencies": [
              "19.2"
            ],
            "details": "The convolution should be a standard discrete convolution. Pay attention to indexing and loop bounds to correctly apply the kernel. The `pow` function from `math.h` (or `cmath` for C++) should be used for `pow(delta, deriv)`, ensuring `vv_dsp_real` compatibility (e.g., `powf` or `pow`).",
            "status": "pending",
            "testStrategy": "Test the convolution and scaling logic with a pre-defined kernel and a simple input signal (e.g., a constant or linear ramp) to verify correct output values, assuming no edge effects for now. Verify the derivative scaling factor is applied correctly."
          },
          {
            "id": 4,
            "title": "Implement Savitzky-Golay Edge Handling",
            "description": "Implement the boundary condition handling based on the `vv_dsp_savgol_mode` parameter. This involves creating a padded version of the input signal `y` before convolution. Implement padding logic for each specified mode (e.g., 'reflect' for symmetric extension, 'constant' for padding with a constant value, 'nearest' for padding with the nearest edge value, 'wrap' for circular padding). The convolution from Subtask 3 will then operate on this padded signal, and the relevant central portion will be copied to the `output` buffer.",
            "dependencies": [
              "19.3"
            ],
            "details": "Allocate memory for the padded signal using `vv_dsp_malloc` and ensure it is freed using `vv_dsp_free` after use. The padding length will depend on the `window_length`. Ensure the padding logic correctly mirrors SciPy's behavior for 'reflect' mode and other common padding strategies.",
            "status": "pending",
            "testStrategy": "Develop specific unit tests for each `vv_dsp_savgol_mode`. Use short signals and verify the padded signal content for each mode. Then, test the full `vv_dsp_savgol` function with these modes and simple signals to ensure correct output at the boundaries."
          },
          {
            "id": 5,
            "title": "Final Integration, Memory Management, and Comprehensive Unit Testing",
            "description": "Integrate all previously developed components (input validation, kernel precomputation, edge handling, convolution, and derivative scaling) into the final `vv_dsp_savgol` function. Ensure robust memory management, using `vv_dsp_malloc` and `vv_dsp_free` for all temporary buffers (e.g., kernel coefficients, padded signal). Create a new test file `tests/savgol_tests.c` and develop comprehensive unit tests using CTest. Tests should cover basic functionality with analytically predictable signals (constant, linear, quadratic, cubic polynomials) for both smoothing (`deriv=0`) and differentiation (`deriv=1`, `deriv=2`). Verify numerical parity and accuracy against a reliable reference (e.g., SciPy's `savgol_filter` outputs). Test all `vv_dsp_savgol_mode` options thoroughly.",
            "dependencies": [
              "19.1",
              "19.2",
              "19.3",
              "19.4"
            ],
            "details": "Pay close attention to error paths and ensure all allocated memory is freed on success or failure. The test suite should include edge cases for `N`, `window_length`, and `polyorder`. Consider testing with both `float` and `double` precision by conditionally compiling the tests if `VV_DSP_USE_DOUBLE` can be toggled for testing.",
            "status": "pending",
            "testStrategy": "Implement a comprehensive CTest suite. Include tests for various signal types (sinusoids, ramps, impulses), different `window_length`/`polyorder`/`deriv` combinations, and all `vv_dsp_savgol_mode` options. Compare outputs against pre-calculated reference values or a known good implementation (e.g., Python's SciPy). Define acceptable numerical error thresholds."
          }
        ]
      },
      {
        "id": 20,
        "title": "Implement Mel filterbank and MFCC feature extraction",
        "description": "Implement Mel filterbank and MFCC feature extraction, including Mel scale conversions, triangular filterbank generation, log-mel spectrogram, and MFCC pipeline using DCT-II.",
        "details": "Create a new module, e.g., `features/mel.h` and `features/mel.c`, to encapsulate Mel filterbank and MFCC functionality.\n\nImplementation steps:\n1.  **Mel Scale Conversions**: Implement `vv_dsp_hz_to_mel(float hz)` and `vv_dsp_mel_to_hz(float mel)` functions, ensuring accurate conversion between Hertz and Mel scales.\n2.  **Triangular Filterbank Generation**: Implement a function, e.g., `vv_dsp_mel_filterbank_create(size_t n_fft, size_t n_mels, float sample_rate, float fmin, float fmax, vv_dsp_mel_variant variant, float** out_filterbank_weights, size_t* out_num_filters, size_t* out_filter_len)`, to generate triangular Mel filterbank weights. This function should support both HTK and Slaney variants and return the filterbank as a matrix or array of arrays.\n3.  **Log-Mel Spectrogram**: Develop a function that takes a power spectrogram (output from STFT, Task 5), applies the generated Mel filterbank, and then takes the logarithm (e.g., natural log or log base 10, configurable).\n4.  **MFCC Pipeline**: Implement the main MFCC computation function, e.g., `vv_dsp_mfcc(const float* log_mel_spectrogram, size_t num_frames, size_t n_mels, size_t num_mfcc_coeffs, vv_dsp_dct_type dct_type, float lifter_coeff, float* out_mfcc_coeffs)`. This function will take the log-mel spectrogram and apply the Discrete Cosine Transform (DCT-II, from Task 13) to produce the MFCCs. Include an optional 'lifter' coefficient for post-DCT processing.\n5.  **Configurable Parameters**: Ensure the implementation supports configurable parameters such as `sample_rate`, `n_mels`, `fmin`, `fmax`, `n_fft`, `hop_length` (for context, as STFT handles framing), `dct_type` (specifically DCT-II), and `lifter`.\n6.  **Memory Management**: Design for efficient memory allocation and deallocation for filterbank weights and intermediate buffers.\n7.  **SIMD Optimization**: Where applicable, ensure loops are SIMD-friendly for performance.\n8.  **Error Handling**: Implement robust error handling for invalid input parameters (e.g., `n_mels` too large, `fmin` > `fmax`).",
        "testStrategy": "Utilize the Task 11 Python-based verification harness to compare `vv-dsp` outputs against `librosa` and `scipy` references within defined numerical tolerances.\n\n**Unit Tests (CTest):**\n-   Verify `vv_dsp_hz_to_mel` and `vv_dsp_mel_to_hz` for accuracy across a range of frequencies and ensure `hz_to_mel(mel_to_hz(x))` returns `x` within tolerance.\n-   Test filterbank generation for both HTK and Slaney variants: verify filter shapes, center frequencies, and bandwidths against known analytical values or `librosa` references.\n-   Test the log-mel spectrogram computation with various STFT inputs (e.g., pure tones, white noise, speech segments).\n-   Test the full MFCC pipeline with synthetic signals and real audio snippets, varying `n_mels`, `fmin`, `fmax`, `num_mfcc_coeffs`, and `lifter`.\n\n**Golden Vectors:**\n-   Generate golden vectors for fixed input audio and parameter sets using `librosa` (e.g., `librosa.feature.melspectrogram` and `librosa.feature.mfcc`). Compare `vv-dsp` outputs against these golden vectors.\n\n**Parity Checks:**\n-   Perform parity checks on random audio snippets, comparing `vv-dsp` and `librosa` outputs for both log-mel spectrograms and MFCCs.\n\n**Edge Cases:**\n-   Test with `n_mels` values close to or exceeding `n_fft/2` (number of unique FFT bins).\n-   Test with `fmin` close to 0 Hz and `fmax` close to the Nyquist frequency.\n-   Test with very short audio inputs or inputs that result in a single frame.\n-   Test with zero-padded inputs to ensure correct behavior.\n-   Test with `lifter_coeff` set to 0 (no liftering) and other typical values.\n\n**Performance:**\n-   Conduct basic performance checks to ensure the full pipeline executes efficiently, especially for typical audio processing sample rates (e.g., 44.1 kHz, 48 kHz).",
        "status": "pending",
        "dependencies": [
          2,
          3,
          4,
          5,
          11,
          13
        ],
        "priority": "low",
        "subtasks": [
          {
            "id": 1,
            "title": "Module Setup and Mel Scale Conversion Functions",
            "description": "Create the new module files `include/vv_dsp/features/mel.h` and `src/features/mel.c`. Implement the core Mel scale conversion functions `vv_dsp_hz_to_mel(float hz)` and `vv_dsp_mel_to_hz(float mel)`. Define the `vv_dsp_mel_variant` enumeration (e.g., `VV_DSP_MEL_VARIANT_HTK`, `VV_DSP_MEL_VARIANT_SLANEY`) to specify the Mel scale formula variant.",
            "dependencies": [],
            "details": "Ensure `vv_dsp_hz_to_mel` and `vv_dsp_mel_to_hz` provide accurate conversions. Use `float` for all calculations. Follow existing `vv-dsp` conventions for header guards, function naming, and basic input validation (e.g., non-negative frequency).",
            "status": "pending",
            "testStrategy": "Unit tests for `vv_dsp_hz_to_mel` and `vv_dsp_mel_to_hz` to verify accuracy across a wide range of frequencies, including edge cases (e.g., 0 Hz), and ensure `hz_to_mel(mel_to_hz(x))` returns `x` within numerical tolerance."
          },
          {
            "id": 2,
            "title": "Triangular Mel Filterbank Generation",
            "description": "Implement `vv_dsp_mel_filterbank_create(size_t n_fft, size_t n_mels, float sample_rate, float fmin, float fmax, vv_dsp_mel_variant variant, float** out_filterbank_weights, size_t* out_num_filters, size_t* out_filter_len)`. This function will calculate the Mel points, convert them back to Hertz, and then generate the triangular filter weights based on the specified `n_fft`, `sample_rate`, frequency range, and Mel variant. The `out_filterbank_weights` should be allocated dynamically and represent the filterbank matrix.",
            "dependencies": [
              "20.1"
            ],
            "details": "The filterbank weights should be normalized. Pay close attention to the indexing and bin mapping from FFT bins to Mel bins. Implement robust error handling for invalid parameters (e.g., `n_mels` too large, `fmin` > `fmax`, `n_fft` too small). Ensure proper memory allocation for `out_filterbank_weights` using `vv_dsp_malloc` and document its expected deallocation.",
            "status": "pending",
            "testStrategy": "Unit tests to verify the shape and values of the generated filterbank weights for various `n_fft`, `n_mels`, `sample_rate`, `fmin`, `fmax`, and `variant` combinations. Compare against known reference implementations (e.g., `librosa`) for small, predictable inputs."
          },
          {
            "id": 3,
            "title": "Log-Mel Spectrogram Computation",
            "description": "Develop a function, e.g., `vv_dsp_compute_log_mel_spectrogram(const float* power_spectrogram, size_t num_frames, size_t n_fft_bins, const float* filterbank_weights, size_t n_mels, float log_epsilon, float* out_log_mel_spectrogram)`, that takes a power spectrogram (output from STFT, Task 5), applies the pre-generated Mel filterbank weights, and then takes the logarithm (natural log). A small `log_epsilon` should be added to the Mel energies before taking the logarithm to avoid `log(0)`.",
            "dependencies": [
              "20.2"
            ],
            "details": "The power spectrogram is typically `(n_fft/2 + 1)` bins per frame. The function should iterate through each frame, apply the filterbank (effectively a weighted sum or matrix multiplication), and then apply the logarithm. Consider the memory layout of the input `power_spectrogram` (e.g., contiguous frames).",
            "status": "pending",
            "testStrategy": "Unit tests with synthetic power spectrograms and known filterbank weights to verify correct log-Mel spectrogram output. Compare against `librosa` for a full pipeline test using the Task 11 verification harness."
          },
          {
            "id": 4,
            "title": "MFCC Coefficient Computation (DCT-II and Liftering)",
            "description": "Implement the main MFCC computation function, `vv_dsp_mfcc(const float* log_mel_spectrogram, size_t num_frames, size_t n_mels, size_t num_mfcc_coeffs, vv_dsp_dct_type dct_type, float lifter_coeff, float* out_mfcc_coeffs)`. This function will take the log-mel spectrogram and apply the Discrete Cosine Transform (DCT-II, from Task 13) to produce the MFCCs. Include an optional 'lifter' coefficient for post-DCT processing, applying the lifter to the resulting MFCCs.",
            "dependencies": [
              "20.3"
            ],
            "details": "For each frame of the `log_mel_spectrogram`, call `vv_dsp_dct_forward` with `VV_DSP_DCT_TYPE_II`. Ensure `num_mfcc_coeffs` is less than or equal to `n_mels`. Implement the liftering formula: `mfcc[i] = mfcc[i] * (1 + (lifter_coeff / 2) * sin(M_PI * i / lifter_coeff))` for `i > 0`. Handle the case where `lifter_coeff` is 0 (no liftering).",
            "status": "pending",
            "testStrategy": "Unit tests for `vv_dsp_mfcc` with synthetic log-mel spectrograms to verify correct DCT application and liftering. Cross-validate against `librosa` using the Task 11 harness for end-to-end MFCC computation."
          },
          {
            "id": 5,
            "title": "MFCC Context Management, Pipeline Integration, and Optimization",
            "description": "Design and implement a context structure (e.g., `vv_dsp_mfcc_plan_t`) to manage pre-computed resources like the Mel filterbank and potentially DCT plans. Implement `vv_dsp_mfcc_init(...)` to allocate and initialize this context, including filterbank creation, and `vv_dsp_mfcc_destroy(...)` for proper cleanup. Create a high-level `vv_dsp_mfcc_process(...)` function that takes a power spectrogram and a context, orchestrating the entire log-Mel and MFCC pipeline. Ensure all configurable parameters (`sample_rate`, `n_mels`, `fmin`, `fmax`, `n_fft`, `dct_type`, `lifter`) are properly exposed and handled. Review the entire module for SIMD optimization opportunities and ensure robust error handling across all public API functions.",
            "dependencies": [
              "20.1",
              "20.2",
              "20.3",
              "20.4"
            ],
            "details": "The `vv_dsp_mfcc_plan_t` should encapsulate the `filterbank_weights` and potentially a `vv_dsp_dct_plan_t` if beneficial for performance. The `vv_dsp_mfcc_process` function should handle the full flow from power spectrogram input to MFCC output, managing intermediate buffers. Prioritize SIMD-friendly loop structures, especially in the filterbank application and DCT input/output handling. All public functions should return `vv_dsp_status` for error reporting.",
            "status": "pending",
            "testStrategy": "Comprehensive integration tests using the Task 11 Python harness to compare `vv-dsp` MFCC outputs against `librosa` for various audio inputs and parameter configurations. Test memory leak detection with Valgrind for `vv_dsp_mfcc_init`/`vv_dsp_mfcc_destroy` cycles. Performance benchmarks to evaluate SIMD effectiveness."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-10T09:22:31.972Z",
      "updated": "2025-08-11T06:14:13.620Z",
      "description": "Tasks for master context"
    }
  }
}